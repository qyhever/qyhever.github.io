<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>正在缓冲99%</title>
  
  <subtitle>Qin Yonghao&#39;s Personal Website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qyhever.top/"/>
  <updated>2018-10-30T14:09:00.831Z</updated>
  <id>http://qyhever.top/</id>
  
  <author>
    <name>pink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七牛云上传图片，从前端到后端</title>
    <link href="http://qyhever.top/2018/09/21/%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF/"/>
    <id>http://qyhever.top/2018/09/21/七牛云上传图片，从前端到后端/</id>
    <published>2018-09-21T09:42:09.000Z</published>
    <updated>2018-10-30T14:09:00.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上传图片是很常见的需求，方法也有很多。本次使用的是七牛云的对象存储，七牛云的oss做的还是比较出色的。</p><p>七牛云的上传大体分为两种</p><ul><li>向服务端请求七牛的文件上传 token，然后将文件上传至七牛（授权式上传）</li><li>将文件直接上传到服务端，再由服务端将文件传输至七牛</li></ul><p>本文会把两种方法都实现，实际开发根据情况选用</p><h3 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h3><p>formData + axios + koa + koa-body</p><h3 id="前端调用sdk"><a href="#前端调用sdk" class="headerlink" title="前端调用sdk"></a>前端调用sdk</h3><p>七牛云的sdk可以通过script标签引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://unpkg.com/qiniu-js@2.4.0/dist/qiniu.min.js</span><br></pre></td></tr></table></figure><ul><li><p>通过sctipt标签引入该文件，会在全局生成名为 <code>qiniu</code> 的对象</p></li><li><p>通过npm安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qiniu-js --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qiniu <span class="keyword">from</span> <span class="string">'qiniu-js'</span></span><br></pre></td></tr></table></figure></li></ul><p>qiniu-sdk</p><p>主要api，qiniu.upload(file, key, token, putExtra, config)</p><ul><li>file：Blob对象</li><li>key：文件名</li><li>token：上传验证信息，前端通过接口请求后端获得</li><li>config：上传配置参数</li><li>putExtra：额外配置参数</li></ul><p>调用成功后返回一个<strong>observable</strong>对象，调用它的subscribe方法获取到响应结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(&#123;</span><br><span class="line">  complete(res) &#123;</span><br><span class="line">    <span class="comment">// 上传完成的响应信息，res 包含 hash、key两个属性（默认）</span></span><br><span class="line">  &#125;,</span><br><span class="line">  next(res) &#123;</span><br><span class="line">    <span class="comment">// 接收上传进度信息，res 包含loaded、total、percent三个属性，提供上传进度信息。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  error(err) &#123;</span><br><span class="line">    <span class="comment">// 上传错误触发，err 包含 code、message、isRequestError 三个属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>前端代码：发送请求使用 axios</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'upload'</span>);</span><br><span class="line">fileInput.addEventListener(<span class="string">'change'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.target.files[<span class="number">0</span>]; <span class="comment">// Blob，文件流对象</span></span><br><span class="line">  <span class="comment">// 通过后端接口获取七牛云的 token</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(<span class="string">'/qiniuToken'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; token, key &#125; = res.data;</span><br><span class="line">  <span class="keyword">const</span> putExtra = &#123;</span><br><span class="line">    fname: <span class="string">''</span>, <span class="comment">// 文件原文件名</span></span><br><span class="line">    params: &#123;&#125;, <span class="comment">// 用来放置自定义变量</span></span><br><span class="line">    mimeType: <span class="literal">null</span> <span class="comment">// 用来限制上传文件类型，为 null 时表示不对文件类型限制；eg: ["image/png", "image/jpeg"]</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    useCdnDomain: <span class="literal">true</span>, <span class="comment">// 开启 cdn 加速域名</span></span><br><span class="line">    region: <span class="literal">null</span>, <span class="comment">// 为 null 会自动解析上传区域</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 调用 qiniu.upload 上传图片，生成 observable 实例</span></span><br><span class="line">  <span class="keyword">const</span> observable = qiniu.upload(file, key, token, putExtra, config);</span><br><span class="line">  <span class="comment">// 调用 observable 的 subscribe 方法，获取响应结果</span></span><br><span class="line">  observable.subscribe(&#123;</span><br><span class="line">    complete(data) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; key &#125; = data;</span><br><span class="line">      <span class="comment">// 把返回的 key 与 域名拼接，就是图片地址</span></span><br><span class="line">      <span class="keyword">const</span> url = <span class="string">'配置的域名'</span> + key;</span><br><span class="line">    &#125;,</span><br><span class="line">    next(res) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error(err) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端代码：后端实现使用 koa</p><p>因为只需要返回 token，所以相对简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/qiniuToken'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 鉴权对象 mac</span></span><br><span class="line">  <span class="keyword">const</span> accessKey = <span class="string">'your access key'</span>;</span><br><span class="line">  <span class="keyword">const</span> secretKey = <span class="string">'your secret key'</span>;</span><br><span class="line">  <span class="keyword">const</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    scope: <span class="string">'your bucket'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(options);</span><br><span class="line">  <span class="keyword">const</span> token = putPolicy.uploadToken(mac);</span><br><span class="line">  <span class="keyword">const</span> key = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// key 只需要随机不重复就可以</span></span><br><span class="line">  ctx.body = &#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">data</span>: &#123; token, key &#125; &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="后端直传"><a href="#后端直传" class="headerlink" title="后端直传"></a>后端直传</h3><p>前端只需要传递一个 file 文件流对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fileInput.addEventListener(<span class="string">'change'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.target.files[<span class="number">0</span>]; <span class="comment">// Blob，文件流对象</span></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="string">'file'</span>, formData); <span class="comment">// file 是后端接受的字段</span></span><br><span class="line">  <span class="comment">// axios 识别到参数为 formData 类型后，会自动修改 Content-Type 为 multipart/form-data</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.post(<span class="string">'/qiniu'</span>, formData);</span><br><span class="line">  <span class="keyword">const</span> &#123; url &#125; = res.data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端需要调用 qiniu-sdk</p><p>先下载 koa-body</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S koa-body</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);</span><br><span class="line"><span class="keyword">const</span> koaBodyOpts = &#123;</span><br><span class="line">  multipart: <span class="literal">true</span>, <span class="comment">// 默认不会接受 formData 参数，需要开启</span></span><br><span class="line">  formLimit: <span class="string">'15mb'</span> <span class="comment">// 默认 56 kb，尽量设置大一些</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在全局使用 koa-body</span></span><br><span class="line">app.use(koaBody(koaBodyOpts));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个路由使用</span></span><br><span class="line">router.post(<span class="string">'/qiniu'</span>, koaBody(koaBodyOpts), <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; file &#125; = ctx.request.body.files;</span><br><span class="line">  <span class="keyword">const</span> ext = path.extname(file.name);</span><br><span class="line">  <span class="keyword">const</span> fileName = +<span class="keyword">new</span> <span class="built_in">Date</span>() + ext;</span><br><span class="line">  <span class="keyword">const</span> localFile = file.path;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> qiniuPut(fileName, localFile);</span><br><span class="line">    <span class="keyword">const</span> url = qiniuOpts.url + res.key;</span><br><span class="line">    ctx.body = &#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">data</span>: &#123; url &#125; &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    ctx.body = &#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">'上传失败'</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取七牛云 token</span></span><br><span class="line"><span class="keyword">const</span> qiniuToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> accessKey = <span class="string">'your access key'</span>;</span><br><span class="line">  <span class="keyword">const</span> secretKey = <span class="string">'your secret key'</span>;</span><br><span class="line">  <span class="keyword">const</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    scope: <span class="string">'your bucket'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(options);</span><br><span class="line">  <span class="keyword">const</span> uploadToken = putPolicy.uploadToken(mac);</span><br><span class="line">  <span class="keyword">return</span> uploadToken;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 七牛云文件上传</span></span><br><span class="line"><span class="keyword">const</span> qiniuPut = <span class="function">(<span class="params">key, localFile</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> uploadToken = qiniuToken();</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">new</span> qiniu.conf.Config();</span><br><span class="line">  <span class="comment">// 空间对应的机房</span></span><br><span class="line">  config.zone = qiniu.zone.Zone_z2;</span><br><span class="line">  <span class="keyword">const</span> formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config);</span><br><span class="line">  <span class="keyword">const</span> putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    formUploader.putFile(uploadToken, key, localFile, putExtra, (respErr, respBody, respInfo) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (respErr) &#123;</span><br><span class="line">        reject(respErr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(respBody);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>七牛云的 api 还有很多，有兴趣可以看看<a href="https://developer.qiniu.com/kodo/sdk/1289/nodejs#rs-batch-stat" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="nodejs" scheme="http://qyhever.top/categories/nodejs/"/>
    
      <category term="koa" scheme="http://qyhever.top/categories/nodejs/koa/"/>
    
    
      <category term="nodejs" scheme="http://qyhever.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>新兴API - requestAnimationFrame</title>
    <link href="http://qyhever.top/2018/06/21/%E6%96%B0%E5%85%B4API-requestAnimationFrame/"/>
    <id>http://qyhever.top/2018/06/21/新兴API-requestAnimationFrame/</id>
    <published>2018-06-21T08:19:27.000Z</published>
    <updated>2018-11-23T18:23:22.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>js中的定时器并不那么准确，定时器的设定时间只是指定将代码添加到浏览器 UI 线程队列中的等待时间，如果队列前面已经加入了其他任务，那么就需要等待之前的任务完成。</p><p>通常情况下，js中的动画都是使用定时器设定约 17ms 执行，这是大多数电脑显示器的重绘频率，各个浏览器对于定时器的精确度也不一致。</p><p>为了解决计时器与循环间隔的问题，js引入了 requestAnimationFrame()方法，专门用来完成动画。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>requestAnimationFrame() 方法接受一个参数，即在重绘屏幕前调用的一个函数，这个函数负责改变下一次重绘时的 DOM 样式，可以像以前使用 setTimeout() 一样，把多个对 requestAnimationFrame() 的调用连缀起来。</p><p>模拟一个简单的进度条：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">style</span>=<span class="string">"width:1px;height:17px;background:#0f0;"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"run"</span>&gt;</span>Run<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 部分</span></span><br><span class="line"><span class="keyword">var</span> animationId = <span class="literal">null</span>,</span><br><span class="line">    barEl = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>),</span><br><span class="line">    progress = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  progress += <span class="number">1</span>;</span><br><span class="line">  barEl.style.width = progress + <span class="string">'%'</span>;</span><br><span class="line">  barEl.innerHTML = progress + <span class="string">'%'</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    animationId = requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(step); <span class="comment">// step()</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'run'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  barEl.style.width = <span class="string">'1px'</span>;</span><br><span class="line">  progress = <span class="number">0</span>;</span><br><span class="line">  cancelAnimationFrame(animationId);</span><br><span class="line">  requestAnimationFrame(step);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>因为 requestAnimationFrame() 只运行一次传入的函数，因此在需要再次修改 UI 从而生成动画时，需要再次手动调用。</p><p>考虑到兼容性问题，采用以下方式处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在大量数据渲染时，也可以考虑使用 requestAnimationFrame()。</p><p>先看看使用 定时器 的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleChunk</span>(<span class="params">data, len, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      fn(data.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!data.length) &#123; <span class="comment">// 没有数据了</span></span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      start();</span><br><span class="line">    &#125;, <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 10万 数据</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = handleChunk(arr, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = val;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;);</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>使用 requestAnimationFrame() 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleChunk</span>(<span class="params">data, len, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">batch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      fn(data.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data.length) &#123;</span><br><span class="line">      requestAnimationFrame(batch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 10万 数据</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = handleChunk(arr, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = val;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;);</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>以后，实现动画或者需要计时渲染时，可以使用 requestAnimationFrame() 来处理，浏览器内部对此会有优化，相较于 setTimeout() 和 setInterval() 要好很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你真的会用JSON.stringify吗</title>
    <link href="http://qyhever.top/2018/05/10/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8JSON-stringify%E5%90%97/"/>
    <id>http://qyhever.top/2018/05/10/你真的会用JSON-stringify吗/</id>
    <published>2018-05-10T12:10:05.000Z</published>
    <updated>2018-06-20T13:30:25.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/images/json/json.png" alt="json"></p><p>JSON是 js 的一个严格的子集，利用了 js 中的一些模式来表示结构化数据。关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。虽然具有相同的语法格式，但 JSON 并不属于 js。而且，并不只有 js 才使用 JSON，比较 JSON 只是一种数据格式。很多编程语言都有针对 JSON 的解析器和序列化器。</p><h3 id="JSON对象的方法"><a href="#JSON对象的方法" class="headerlink" title="JSON对象的方法"></a>JSON对象的方法</h3><p>JSON对象有两个方法：<code>stringify()</code>和<code>parse()</code>，分别用于将 js 对象序列化为 JSON 字符串 和 将 JSON 字符串解析为原生 js 值。</p><p>这两个方法，我们经常使用，可以说只要涉及到数据传输与存储，大部分情况都离不开这两个方法。</p><p>在开发过程中，可能是像下面这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;<span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line">localStorage.setItem(<span class="string">'user'</span>, <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'...'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(xhr.reponseText);</span><br><span class="line">      <span class="comment">// do...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的JSON对象方法使用很常见，不过，这只是这两个方法最简单的使用，它们还有更强大的功能。</p><p>默认情况下，<code>JSON.stringify()</code>输出的 JSON 字符串不包含任何空格字符串或缩进。实际上，<code>JSON.stringify()</code>处理要序列化的 js 对象外，还可以接受另外两个参数，这两个参数用于指定不同的方式序列化 js 对象，第一个参数是过滤器，可以数组或者函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入的控制 JSON 的序列化。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h5><p>如果过滤器是数组，那么 <code>JSON.stringify()</code>的结果中将只包含数组中列出的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = &#123;</span><br><span class="line">  title: <span class="string">'Scripting language'</span>,</span><br><span class="line">  author: <span class="string">'Brendan Eich'</span>,</span><br><span class="line">  birth: <span class="number">1995</span>,</span><br><span class="line">  universalStandard: [<span class="string">'es3'</span>, <span class="string">'es2015'</span>],</span><br><span class="line">  latestStandard: <span class="string">'es2017'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js, [<span class="string">'title'</span>, <span class="string">'birth'</span>]);</span><br><span class="line"><span class="comment">// "&#123;"title":"Scripting language","birth":1995&#125;"</span></span><br></pre></td></tr></table></figure><p>上面的<code>JSON.stringify()</code>的第二个参数是一个数组，其中包含两个字符串：“title”、“birth”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就只会包含这两个属性。利用这个特性我们可以实现数据的过滤，扔掉一些不需要的数据。</p><p>如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性（键）名和属性值。根据键名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对的结构时，键名可以是空字符串。为了改变序列化对象的结果，函数的返回值就是相应键的值。如果返回<code>undefined</code>，那么相应的属性会被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'universalStandard'</span>: <span class="keyword">return</span> value.join(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'birth'</span>: <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'author'</span>: <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// "&#123;"title":"Scripting language","birth":2000,"universalStandard":"es3,es2015","latestStandard":"es2017"&#125;"</span></span><br></pre></td></tr></table></figure><p>经过回调函数的处理，可以对数据做一些初始化处理。</p><h5 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h5><p><code>JSON.stringify()</code>的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js, <span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line"><span class="string">"&#123;</span></span><br><span class="line"><span class="string">    "</span>title<span class="string">": "</span>Scripting language<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>author<span class="string">": "</span>Brendan Eich<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>birth<span class="string">": 1995,</span></span><br><span class="line"><span class="string">    "</span>universalStandard<span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>es3<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>es2015<span class="string">"</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "</span>latestStandard<span class="string">": "</span>es2017<span class="string">"</span></span><br><span class="line"><span class="string">&#125;"</span></span><br></pre></td></tr></table></figure><p>第三个参数传入数值后，结果字符串中插入了换行符提高了可读性。最大的缩进为10，大于10的值将自动转换为10。</p><p>如果缩进参数是一个字符串，那么这个字符串在 JSON 字符串被用作缩进字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js, <span class="literal">null</span>, <span class="string">'--'</span>);</span><br><span class="line"><span class="string">"&#123;</span></span><br><span class="line"><span class="string">--"</span>title<span class="string">": "</span>Scripting language<span class="string">",</span></span><br><span class="line"><span class="string">--"</span>author<span class="string">": "</span>Brendan Eich<span class="string">",</span></span><br><span class="line"><span class="string">--"</span>birth<span class="string">": 1995,</span></span><br><span class="line"><span class="string">--"</span>universalStandard<span class="string">": [</span></span><br><span class="line"><span class="string">----"</span>es3<span class="string">",</span></span><br><span class="line"><span class="string">----"</span>es2015<span class="string">"</span></span><br><span class="line"><span class="string">--],</span></span><br><span class="line"><span class="string">--"</span>latestStandard<span class="string">": "</span>es2017<span class="string">"</span></span><br><span class="line"><span class="string">&#125;"</span></span><br></pre></td></tr></table></figure><h5 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON()方法"></a>toJSON()方法</h5><p>可以在对象上调用<code>toJSON()</code>方法，返回其自身的 JSON 数据格式，可以为任何对象添加<code>toJSON()</code>方法，自定义对象进行序列化的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = &#123;</span><br><span class="line">  title: <span class="string">'Scripting language'</span>,</span><br><span class="line">  author: <span class="string">'Brendan Eich'</span>,</span><br><span class="line">  birth: <span class="number">1995</span>,</span><br><span class="line">  universalStandard: [<span class="string">'es3'</span>, <span class="string">'es2015'</span>],</span><br><span class="line">  latestStandard: <span class="string">'es2017'</span>,</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js);</span><br><span class="line"><span class="comment">// "Scripting language"</span></span><br></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><code>JSON.parse()</code>方法可以接收第二个参数，该参数是一个函数，将在每个键值对上调用。一般，把<code>JSON.stringify()</code>的回调函数称为 替换（过滤）函数 ，把这里的函数称为 还原函数。这两个函数的使用方法是相同的，接收键和值两个参数，并且都需要返回一个值。</p><p>如果返回<code>undefined</code>，则从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = &#123;</span><br><span class="line">  title: <span class="string">'Scripting language'</span>,</span><br><span class="line">  author: <span class="string">'Brendan Eich'</span>,</span><br><span class="line">  birth: <span class="number">1995</span>,</span><br><span class="line">  universalStandard: [<span class="string">'es3'</span>, <span class="string">'es2015'</span>],</span><br><span class="line">  latestStandard: <span class="string">'es2017'</span>,</span><br><span class="line">  currentTime: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(js);</span><br><span class="line"><span class="keyword">var</span> jsCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'currentTime'</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于Date对象，很适合用还原函数来处理。</p><p>对象经过序列化，在进行还原解析可以用于对象的深拷贝，不过此方式有一定缺陷，所有函数及原型成员会被有意忽略，不体现在结果中，值为<code>undefined</code>的任何属性会跳过。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>JSON 是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。JSON 使用 js 语法的子集表示对象、数组、字符串、数值、布尔值和null。相对于XML，JSON 更高效更便利，成为当前主流的数据传输格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>函数节流与防抖</title>
    <link href="http://qyhever.top/2018/04/10/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <id>http://qyhever.top/2018/04/10/函数节流与防抖/</id>
    <published>2018-04-10T12:23:57.000Z</published>
    <updated>2018-11-24T13:14:43.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在浏览器中频繁的 DOM 操作比非 DOM 操作需要更多的内存和 CPU 时间，连续进行过多的 DOM 操作可能导致浏览器挂起，甚至崩溃，从而影响用户体验。</p><p>函数节流和防抖技术，属于高级函数中的一种，作用都是为了防止函数（通常函数中会进行或多或少的 DOM 操作）被高频调用，从而提高性能，加快浏览器反应速度。</p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较常见的如绑定了 onscroll、onresize、onkeyup 这类事件，事件触发会持续执行事件处理的回调函数，意味着浏览器时时刻刻都在进行计算，导致页面出现延迟、卡顿现象。对于此类场景，通常使用函数节流与防抖技术来进行性能优化。</p><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 debounce"></a>函数防抖 debounce</h3><blockquote><p>当调用函数过n毫秒后，才会执行该函数，若在这n毫秒内又调用此函数则将重新计算执行时间</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(handleResize, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>这样每次都会间隔 300 ms 打印，原理：使用闭包实现一个 timer 变量，用来记录上一次调用函数的定时器。在事件触发时不是直接调用函数，在中间有一个间隔。如果两次调用的时间差小于设定值，则清除上一个定时器，再次启动一个定时器，这样就降低了函数的调用频率。</p><p>高程3中的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  clearTimeout(fn.timer);</span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">  fn.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn.call(context);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用需注意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 debounce 只是延时了回调函数，所以不能像前面那样使用</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  debounce(handleResize, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写法和前面有所区别，效果其实是一样，都减少了回调函数的调用频率。但是，函数防抖有点小问题，就是在事件持续触发过程中，执行回调函数的定时器会一直被清除，不会执行，只有在事件停止触发并经过设定值后才执行。这时候，需要通过函数节流解决一直不执行的问题。</p><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h3><blockquote><p>预先设定一个执行周期，当调用函数的时刻大于等于执行周期则执行该函数，然后进入下一个新周期。</p></blockquote><p>方法一：使用一个节流阀来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 flag 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接判断 timerId</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个标记来记录是否到达设定值</p><p>方法二：记录时间差来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>(), timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(), context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (now - start &gt;= delay) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      start = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中记录两次调用函数的时间，大于或等于设定值则执行回调函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数防抖：在设定时间内，回调函数只会调用一次，即触发事件的最后一次。适用于 input 联想搜索场景。</p><p>函数节流：事件持续触发时，每隔一段时间就会调用一次。适用于 onscroll、onresize 此类事件。</p><p>参考：<a href="http://ghmagical.com/article/page/id/4qrB9JeihTKD" target="_blank" rel="noopener">浅谈Debounce 与Throttle</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="高级函数" scheme="http://qyhever.top/tags/%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用vuex共享全局状态</title>
    <link href="http://qyhever.top/2018/04/02/%E4%BD%BF%E7%94%A8vuex%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81/"/>
    <id>http://qyhever.top/2018/04/02/使用vuex共享全局状态/</id>
    <published>2018-04-02T10:23:29.000Z</published>
    <updated>2018-06-29T14:17:28.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p><h3 id="什么是-Vuex"><a href="#什么是-Vuex" class="headerlink" title="什么是 Vuex"></a>什么是 Vuex</h3><p><a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">Vuex </a>是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。状态可以简单理解为数据，如果多个组件需要用到某些数据，有两种方法可以实现非父子组件的通信，事件总线和 Vuex。在数据少的情况下可以使用事件总线机制，当数据复杂起来时，应该考虑使用 Vuex 来做数据共享。</p><h3 id="使用-Vuex"><a href="#使用-Vuex" class="headerlink" title="使用 Vuex"></a>使用 Vuex</h3><ol><li><p>vuex 是单独的库，需要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex</span><br></pre></td></tr></table></figure></li><li><p>在 src 目录下新建 store 目录，专门放置 vuex 相关文件，内部文件组织如下：</p><ol><li>store.js：组装模块并导出 store，也可命名（index.js）</li><li>state.js：定义初始 state（状态 或 数据）</li><li>getters.js：获取从 state 中派生出的一些状态</li><li>mutation-types.js：单独存放 mutation 事件类型名字</li><li>mutations.js：根级别的 mutation，用于通过 commit 调用对应方法，来修改状态<ol start="6"><li>actions.js：根级别的 action，用于通过 dispatch 触发对应方法，来commit mutation    </li></ol></li></ol></li><li><p>在 store.js 文件中，组装模块并导出 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在入口文件 main.js 中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store form <span class="string">'./store/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store, <span class="comment">// 将 store 注册到根实例中，这样所有组件都可以使用 store</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>定义全局共享的状态，可以简单理解为数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  singer: &#123;&#125;,</span><br><span class="line">  count: <span class="number">1</span>,</span><br><span class="line">  todos: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'eating'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'sleeping'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'work'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'movie'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用 Vuex 中的状态</p><ol><li><p>通过 this.$store.state 来访问，前面已经把 store 挂载到了根实例上，所有组件都能访问 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么是 computed 计算属性？想一下，在别的组件中如果改变了 count 这个状态，那么这个组件中也需要改变，所以需要使用 计算属性，保证同步改变。</p></li><li><p>mapState 辅助函数</p><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些冗余。Vuex 提供 mapState 辅助函数，来帮助我们生成计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">'count'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapState 相当于是一种语法糖，可以把状态自动映射到 计算属性 中，简化了操作</p><p>​</p></li></ol><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>一般在组件中使用 Vuex 中的状态，会使用 getter 包装一层，在这里可以对状态进行过滤 或者 派生出一些状态。可以理解为 store 中的计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  singer: <span class="function"><span class="params">state</span> =&gt;</span> state.singer,</span><br><span class="line">  count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">  todos: <span class="function"><span class="params">state</span> =&gt;</span> state.todos,</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  remainTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> id =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接受其他 getter 作为第二个参数</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中访问 getter</p><ol><li><p>通过 this.$store.getters来访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.count</span><br><span class="line">  &#125;,</span><br><span class="line">  doneTodos() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodos</span><br><span class="line">  &#125;,</span><br><span class="line">  firstTodo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.getTodoById(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapGetters 辅助函数，将 store 中的 getter 映射到局部计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">'count'</span>, <span class="string">'todos'</span>, <span class="string">'doneTodos'</span>, <span class="string">'remainTodos'</span>, <span class="string">'doneTodosCount'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将 getter 属性重命名，mapGetters 函数传入对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h3><p>Vuex 中通过提交 mutation 来更新状态，mutaion 非常类似于事件：每个 mutation都有一个字符串的 <strong>事件类型（type）</strong>和一个<strong>回调函数（callback）</strong>，这个回调函数就是用来变更状态的地方，有两个参数：state 和 payload</p><p>mutation 可以简单理解为 函数（方法），类似于组件 methods 中定义的方法，通过在组件中调用 mutaion 来变更状态。两个参数，state 用来获取 store 中的状态，payload 是在组件中调用 mutation 传入的参数</p><p>因为 mutation 的名字是字符串，且不可改变，一般做法是单独放在 mutation-types.js 文件中，便于维护，把字符串定义为常量，在 IDE 中也会有相应的智能提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> ADD_COUNT_ONE = <span class="string">'ADD_COUNT_ONE'</span></span><br><span class="line"><span class="keyword">export</span> ADD_COUNT_CUSTOM = <span class="string">'ADD_COUNT_CUSTOM'</span></span><br><span class="line"><span class="keyword">export</span> TOGGLE_TODO = <span class="string">'TOGGLE_TODO'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> type <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  [type.ADD_COUNT_ONE] (state) &#123;</span><br><span class="line">    state.count += <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [type.ADD_COUNT_CUSTOM] (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;,</span><br><span class="line">  [type.TOGGLE_TODO] (state, id) &#123;</span><br><span class="line">    state.todos.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.id === id) &#123;</span><br><span class="line">        item.done = !item.done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mutations</span><br></pre></td></tr></table></figure><p>在组件中提交 mutation</p><ol><li><p>通过 this.$store.commit 提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  handleMethod() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'ADD_COUNT_ONE'</span>) <span class="comment">// store 中的 count 自增 1</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'ADD_COUNT_CUSTOM'</span>, <span class="number">10</span>) <span class="comment">// store 中的 count 自增 10</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'TOGGLE_TODO'</span>, <span class="number">0</span>) <span class="comment">// 改变第一个 todo 任务的 done 属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>mapMutations 辅助函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations([<span class="string">'ADD_COUNT_ONE'</span>, <span class="string">'ADD_COUNT_CUSTOM'</span>]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    toggleTodo: <span class="string">'TOGGLE_TODO'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  handleMethod() &#123;</span><br><span class="line">    <span class="keyword">this</span>.ADD_COUNT_ONE()</span><br><span class="line">    <span class="keyword">this</span>.ADD_COUNT_CUSTOM()</span><br><span class="line">    <span class="keyword">this</span>.toggleTodo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>改变状态可以在组件中 提交 mutation，通过 action 也可以提交 mutation 来改变状态</p><p>action 可以包含任何异步的操作</p><p>action 函数接受两个参数，context（上下文对象）和 payload。context 与 store 实例具有相同方法和属性，通过 context 可以访问到 state.state、state.commit，payload 则是在组件中触发 action 传递的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// 可以进行任何异步操作</span></span><br><span class="line">  addCountOne(context) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'ADD_COUNT_ONE'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// 使用 参数解构 简化代码</span></span><br><span class="line">  addCountCustom(&#123; commit &#125;, n) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'ADD_COUNT_CUSTOM'</span>, n)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  getSingerById(&#123; commit &#125;, id) &#123;</span><br><span class="line">    <span class="comment">// 异步请求</span></span><br><span class="line">    axios.get(<span class="string">'xxx'</span>, &#123; <span class="attr">params</span>: &#123; id &#125; &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'SET_SINGER'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getSinger(&#123; commit &#125;, id) &#123;</span><br><span class="line">    <span class="comment">// 使用 promise 包装</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios.get(<span class="string">'xxx'</span>, &#123; <span class="attr">params</span>: &#123; id &#125; &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions</span><br></pre></td></tr></table></figure><p>在组件中触发 action</p><ol><li><p>通过 this.$store.dispatch 触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  handle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addCountOne'</span>) <span class="comment">// 一秒 后，store 中的 count 自增 1</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addCountCustom'</span>, <span class="number">10</span>) <span class="comment">// 一秒 后，store 中的 count 自增 10</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'getSingerById'</span>, <span class="number">5</span>) <span class="comment">// 请求了 id 为 5 的数据，将数据保存在了 store 中</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'getSinger'</span>, <span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapActions 辅助函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([<span class="string">'addCountOne'</span>, <span class="string">'addCountCustom'</span>, <span class="string">'getSingerById'</span>]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    getSingerData: <span class="string">'getSinger'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  handleMethod() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addCountOne()</span><br><span class="line">    <span class="keyword">this</span>.addCountCustom(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">this</span>.getSingerById(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">this</span>.getSingerData(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>可以使用官方推荐的 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>插件</p><p><img src="/images/vuex/vuex-devtools.png" alt="vuex-devtools"></p><p>Vuex 将组件中零散的状态集中起来，进行统一管理，组件间的通信变得更加方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="vue" scheme="http://qyhever.top/categories/vue/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="vue" scheme="http://qyhever.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下安装Nginx</title>
    <link href="http://qyhever.top/2018/03/22/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/"/>
    <id>http://qyhever.top/2018/03/22/CentOS下安装Nginx/</id>
    <published>2018-03-22T09:01:33.000Z</published>
    <updated>2018-06-22T09:44:33.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CentOS下安装-Nginx"><a href="#CentOS下安装-Nginx" class="headerlink" title="CentOS下安装 Nginx"></a>CentOS下安装 Nginx</h3><p>安装 Nginx 之前，需要安装相关的库</p><ul><li>pcre 库，rewrite 模块</li><li>openssl 库，ssl 功能</li><li>zlib 库，gzip 模块</li></ul><h5 id="安装-PCRE"><a href="#安装-PCRE" class="headerlink" title="安装 PCRE"></a>安装 PCRE</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</span><br><span class="line">tar zxvf pcre-8.35.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pcre-8.35</span><br><span class="line">./configure <span class="comment"># 检测环境，若提示缺少 c++，则 yum install -y gcc-c++</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">pcre-config --version</span><br></pre></td></tr></table></figure><h5 id="安装-openssl"><a href="#安装-openssl" class="headerlink" title="安装 openssl"></a>安装 openssl</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.openssl.org/<span class="built_in">source</span>/openssl-1.0.1j.tar.gz</span><br><span class="line">tar zxvf openssl-1.0.1j.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.0.1j</span><br><span class="line">./config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="安装-zlib"><a href="#安装-zlib" class="headerlink" title="安装 zlib"></a>安装 zlib</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.6.2.tar.gz</span><br><span class="line">tar zxvf nginx-1.6.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.6.2</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/src/nginx-1.6.2 --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.35 --with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.0.1j --with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>启动 nginx，目前只能使用 nginx 安装目录下的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/src/nginx-1.6.2/sbin/nginx</span><br></pre></td></tr></table></figure><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在最下面加上</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/src/nginx-1.6.2/sbin</span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment"># 使配置立即生效</span></span><br></pre></td></tr></table></figure><p>配置以后可以在任何目录下使用<code>nginx</code>命令了</p><h5 id="Nginx-其他命令"><a href="#Nginx-其他命令" class="headerlink" title="Nginx 其他命令"></a>Nginx 其他命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx   <span class="comment"># 启动 nginx</span></span><br><span class="line">nginx -s reload     <span class="comment"># 重新载入配置文件</span></span><br><span class="line">nginx -s reopen     <span class="comment"># 重启 nginx</span></span><br><span class="line">nginx -s stop       <span class="comment"># 停止 nginx</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="环境配置" scheme="http://qyhever.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="环境配置" scheme="http://qyhever.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下安装Node.js</title>
    <link href="http://qyhever.top/2018/03/22/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85Node.js/"/>
    <id>http://qyhever.top/2018/03/22/CentOS下安装Node.js/</id>
    <published>2018-03-22T09:01:21.000Z</published>
    <updated>2018-06-22T09:43:25.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CentOS下安装-Node-js"><a href="#CentOS下安装-Node-js" class="headerlink" title="CentOS下安装 Node.js"></a>CentOS下安装 Node.js</h3><ol><li><p>下载源码</p><ul><li><p>可以使用<code>wget</code>，也可以下载到本地然后上传到服务器（官方链接可能比较慢，这里选用的是淘宝镜像）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/ <span class="comment"># 这里是个人习惯，把包下载到这里</span></span><br><span class="line">wget http://npm.taobao.org/mirrors/node/v7.6.0/node-v7.6.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><p>下载的是<code>tar.xz</code>的包，也可以下载<code>tar.gz</code>的包，只不过解压命令略有不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar.xz 包解压</span></span><br><span class="line">xz -d node-v7.6.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v7.6.0-linux-x64.tar</span><br><span class="line"><span class="comment"># tar.gz 包解压</span></span><br><span class="line">tar zxvf node-v7.6.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>查看</p><p>解压编译完成后，目录下应该多了 <code>node-v7.6.0-linux-x64</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> node-v7.6.0-linux-x64/bin</span><br><span class="line">./node -v</span><br></pre></td></tr></table></figure><p>如果出现版本号，则解压编译完成</p></li><li><p>配置环境变量</p><p>现在的 node 只能在 bin 目录下 <code>./node</code>使用，我们需要配置环境变量，另外建立软连接也是可以的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在<code>profile</code>文件下新增两行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set for nodejs</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/src/node-v7.6.0-linux-x64 <span class="comment"># node 包路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NODE_HOME</span>/bin</span><br></pre></td></tr></table></figure><blockquote><p>中等号两边不能有空格，不然会报错<code>not a valid identifier</code></p></blockquote><p>使配置立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>输出版本号表示配置成功</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="环境配置" scheme="http://qyhever.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="环境配置" scheme="http://qyhever.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下安装MongoDB</title>
    <link href="http://qyhever.top/2018/03/22/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://qyhever.top/2018/03/22/CentOS下安装MongoDB/</id>
    <published>2018-03-22T09:01:03.000Z</published>
    <updated>2018-06-22T09:51:48.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CentOS下安装-MongoDB"><a href="#CentOS下安装-MongoDB" class="headerlink" title="CentOS下安装 MongoDB"></a>CentOS下安装 MongoDB</h3><h5 id="安装-mongodb"><a href="#安装-mongodb" class="headerlink" title="安装 mongodb"></a>安装 mongodb</h5><ol><li><p>下载安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.4.tgz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mongodb-linux-x86_64-3.4.4.tgz</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最下面加一行</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/src/mongodb-linux-x86_64-3.4.4/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存后，立即执行生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>安装完成后，使用 mongodb 还需要相关配置</p><ol><li><p>新建数据库目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 /usr/local/src 目录下新建 mongodata</span></span><br><span class="line">-- mongodata</span><br><span class="line">-- data</span><br><span class="line">-- etc</span><br><span class="line">-- mongo.conf</span><br><span class="line">-- logs</span><br><span class="line">-- mongo.log</span><br></pre></td></tr></table></figure></li><li><p>配置文件 mongo.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim mongo.conf</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">dbpath=/usr/<span class="built_in">local</span>/src/mongodata/data</span><br><span class="line">logpath=/usr/<span class="built_in">local</span>/src/mongodata/logs/mongo.log</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=27017</span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">storageEngine=mmapv1 <span class="comment"># 32位需要加上</span></span><br><span class="line">bind_ip=0.0.0.0 <span class="comment"># 允许任意ip连接</span></span><br><span class="line">auth=<span class="literal">true</span> <span class="comment"># 添加用户以后再开启</span></span><br></pre></td></tr></table></figure></li><li><p>通过配置文件启动 mongodb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /usr/<span class="built_in">local</span>/src/mongodata/etc/mongo.conf</span><br></pre></td></tr></table></figure></li><li><p>通过配置文件关闭服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --shutdown -f /usr/<span class="built_in">local</span>/src/mongodata/etc/mongo.conf</span><br></pre></td></tr></table></figure></li><li><p>如果没有指定 auth=true，那么任何人都是可以访问的，这显然不安全，因此需要添加用户，通过用户名来访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: <span class="string">"root"</span>, <span class="built_in">pwd</span>: <span class="string">"123456"</span>, roles: [&#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125;] &#125;)</span><br></pre></td></tr></table></figure></li><li><p>再次启动 mongodb，在命令行中访问就需要用户授权了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.auth(<span class="string">'root'</span>, <span class="string">'123456'</span>)</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="环境配置" scheme="http://qyhever.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="环境配置" scheme="http://qyhever.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>vue中开启keep-alive的注意点</title>
    <link href="http://qyhever.top/2018/03/20/vue%E4%B8%AD%E5%BC%80%E5%90%AFkeep-alive%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://qyhever.top/2018/03/20/vue中开启keep-alive的注意点/</id>
    <published>2018-03-20T12:19:49.000Z</published>
    <updated>2018-06-20T13:30:25.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化一直是前端开发的注意点，通常情况下，当前页面跳转到下一个页面，然后再返回，当前页面会重新渲染DOM然后再获取数据更新DOM，在此过程中造成了不必要的资源浪费。正好vue中提供了<code>keep-alive</code>内置组件，使用<code>keep-alive</code>包裹组件，可以把切换出去的组件保留在内存中，从而保留它的状态避免重新渲染，达到了缓存组件的效果。</p><p>但是，在列表页切换到详情页（动态路由）的时候，就出现问题了。访问详情页之后，返回到列表页，再查看另外的详情页，显示的还是上一次的详情页，说明<code>keep-alive</code>把第一次的详情页缓存了，导致数据不刷新。</p><h3 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h3><p>在项目中，我是这么使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>下面是个人摸索的解决方案，希望对遇到同类问题的有所帮助。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="使用watch监听-route"><a href="#使用watch监听-route" class="headerlink" title="使用watch监听$route"></a>使用watch监听$route</h4><p>每次切换，$route都会变化，可以监听它的变化，再次获取数据，触发页面更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line"><span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> toDepth = to.path.split(<span class="string">'/'</span>).length</span><br><span class="line"><span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">'/'</span>).length</span><br><span class="line"><span class="keyword">if</span> (toDepth &lt; fromDepth) &#123; <span class="comment">// 返回到列表页面，直接退出</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.id = to.params.id <span class="comment">// 获取新路由的参数id</span></span><br><span class="line"><span class="keyword">this</span>.getDetail() <span class="comment">// 更新数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会造成页面闪动，页面会首页显示缓存中的数据，然后再获取新数据</p><h4 id="activated-钩子"><a href="#activated-钩子" class="headerlink" title="activated()钩子"></a>activated()钩子</h4><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。在<code>activated</code> 比较上一次和本次的<code>id</code>，不相同则去请求对应<code>id</code>的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.$route.params.id <span class="comment">// 在 created 或 mounted 钩子中记录上一次的id</span></span><br><span class="line">&#125;,</span><br><span class="line">activated() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lastId !== <span class="keyword">this</span>.$route.params.id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.$route.params.id <span class="comment">// 重置上一次的 id</span></span><br><span class="line">    <span class="keyword">this</span>.getDetail() <span class="comment">// 更新数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在钩子函数内的逻辑，很好的解决了缓存组件的问题</p><h4 id="配置路由元信息"><a href="#配置路由元信息" class="headerlink" title="配置路由元信息"></a>配置路由元信息</h4><p>在路由记录中配置元字段，判断该字段来决定是否开启缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// route.js</span></span><br><span class="line">routes: [</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/list'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/list'</span>, <span class="attr">name</span>: <span class="string">'List'</span>, <span class="attr">component</span>: List &#125;,</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/detail/:id'</span>,</span><br><span class="line">name: <span class="string">'Detail'</span>,</span><br><span class="line">component: Detail,</span><br><span class="line">meta: &#123; <span class="attr">keepAlive</span>: <span class="literal">false</span> &#125; <span class="comment">// 添加keepAlive字段，表明此组件不需要缓存</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用keep-alive --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h4 id="配置include或exclude属性"><a href="#配置include或exclude属性" class="headerlink" title="配置include或exclude属性"></a>配置include或exclude属性</h4><p><code>include</code>和<code>exclude</code>属性允许组件有条件地缓存，二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 逗号分隔字符串 --&gt;</span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>详情了解的，可以看下<a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 不缓存Detail组件 --&gt;</span><br><span class="line">&lt;keep-alive exclude=&quot;Detail&quot;&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 注意Detail是组件名字，在路由记录中配置 --&gt;</span><br></pre></td></tr></table></figure><p>最后的方法是比较好的方法，之前的方法都没有它简洁，推荐使用此方法，没有副作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="vue" scheme="http://qyhever.top/categories/vue/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="vue" scheme="http://qyhever.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>express入门操作</title>
    <link href="http://qyhever.top/2018/03/03/express%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://qyhever.top/2018/03/03/express入门操作/</id>
    <published>2018-03-03T13:30:01.000Z</published>
    <updated>2018-06-20T13:30:25.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="express概述"><a href="#express概述" class="headerlink" title="express概述"></a>express概述</h2><ul><li><p>web应用</p><p>express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。</p></li><li><p>API</p><p>丰富的 HTTP 快捷方法和任意排列组合的中间件，使用 API 变得既快速又简单。</p></li><li><p>性能</p><p>express 保留了 Node.js 的原生方法，只是在它之上扩展了 Web 应用所需的基本功能。</p></li><li><p><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">express官网</a></p></li></ul><h2 id="express使用"><a href="#express使用" class="headerlink" title="express使用"></a>express使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm install express --save</code></p><h3 id="服务器功能"><a href="#服务器功能" class="headerlink" title="服务器功能"></a>服务器功能</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expres  = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。</p><p>路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成。</p><p>结构app.METHOD(path, [callback…], callback)</p><h4 id="路由方法"><a href="#路由方法" class="headerlink" title="路由方法"></a>路由方法</h4><ul><li>常用方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'get request'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'post request'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'put request'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.delete(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'delete request'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>app.use()</li></ul><p><code>app.use()</code>可以匹配到任何路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'use'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>app.all()</li></ul><p><code>app.all()</code> 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，作用是对于一个路径上的所有请求加载中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'all'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="路由句柄"><a href="#路由句柄" class="headerlink" title="路由句柄"></a>路由句柄</h4><p>可以为请求处理提供多个回调函数，行为类似 <a href="http://www.expressjs.com.cn/guide/using-middleware.html" target="_blank" rel="noopener">中间件</a>。</p><p>有多种形式，可以是一个函数、一个函数数组，或者是两者混合。</p><ul><li>一个回调函数处理路由</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/path'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'one callback'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>多个回调函数处理路由（需要调用 <code>next()</code> ）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/path'</span>, (req, res, next) =&gt;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'传递到下一个回调'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'last callback'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>回调函数数组处理路由</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cb0 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cb0'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> cb1 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> cb2 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cb2'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line">app.get(<span class="string">'/path'</span>, [cb0, cb1, cb2]);</span><br></pre></td></tr></table></figure><ul><li>混合使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cb0 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cb0'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> cb1 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line">app.get(<span class="string">'/path'</span>, [cb0, cb1], (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'传递到下一个回调'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'last callback'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h4><p>res对象向客户端返回响应有多种方法，终结请求响应的循环</p><p>如果在路由句柄中一个方法也不调用，请求会一直挂起。</p><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.download" target="_blank" rel="noopener">res.download()</a></td><td style="text-align:left">提示下载文件。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.end" target="_blank" rel="noopener">res.end()</a></td><td style="text-align:left">终结响应处理流程。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.json" target="_blank" rel="noopener">res.json()</a></td><td style="text-align:left">发送一个 JSON 格式的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.jsonp" target="_blank" rel="noopener">res.jsonp()</a></td><td style="text-align:left">发送一个支持 JSONP 的 JSON 格式的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.redirect" target="_blank" rel="noopener">res.redirect()</a></td><td style="text-align:left">重定向请求。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.render" target="_blank" rel="noopener">res.render()</a></td><td style="text-align:left">渲染视图模板。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.send" target="_blank" rel="noopener">res.send()</a></td><td style="text-align:left">发送各种类型的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.sendFile" target="_blank" rel="noopener">res.sendFile</a></td><td style="text-align:left">以八位字节流的形式发送文件。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.sendStatus" target="_blank" rel="noopener">res.sendStatus()</a></td><td style="text-align:left">设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td></tr></tbody></table><h5 id="app-route"><a href="#app-route" class="headerlink" title="app.route()"></a>app.route()</h5><p>使用 <code>app.route()</code> 创建路由路径的链式路由句柄，有助于创建模块化的路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/path'</span>)</span><br><span class="line">.get(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.send(<span class="string">'get'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.send(<span class="string">'post'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.put(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.send(<span class="string">'put'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h5><p>使用 <code>express.Router</code> 类创建模块化、可挂载的路由句柄，<code>Router</code> 实例是一个完整的中间件和路由系统。</p><p>创建route.js，用来处理路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该路由使用的中间件</span></span><br><span class="line">router.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'home page'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/about'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'about page'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>在入口文件index.js中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'./route.js'</span>);</span><br><span class="line">app.use(router);</span><br><span class="line"><span class="comment">// app.use('/www', router); // 第一个参数可以指定虚拟目录，访问时要在前面加上www</span></span><br></pre></td></tr></table></figure><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p><code>express.static(path, [options])</code>是express内置的唯一一个中间件，用来托管静态资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line">app.use(<span class="string">'/www'</span>, express.static(<span class="string">'public'</span>));</span><br><span class="line"><span class="comment">// www为虚拟目录，public为静态资源目录</span></span><br></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>含义等价于“插件”，用于扩展功能的可拆装模块，是处理过程中的一个环节（本质上就是一个函数）。</p><p>位于请求和返回之间的处理函数，使用<code>next()</code>把请求传递到下一个中间件。</p><p>处理方式上和路由句柄类似。</p><h4 id="常用中间件"><a href="#常用中间件" class="headerlink" title="常用中间件"></a>常用中间件</h4><ul><li>body-parser，处理post参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载参数处理中间件（post）</span></span><br><span class="line"><span class="comment">// parse application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"><span class="comment">// parse application/json</span></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理get提交参数</span></span><br><span class="line">app.get(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.qurey); <span class="comment">// express内置获取get参数的</span></span><br><span class="line">    res.send(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理post提交参数</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body); <span class="comment">// body-parser提供的获取post参数的</span></span><br><span class="line">  res.send(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure><ul><li>cookie-parser，处理cookie</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'asdfghjkl'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie</span></span><br><span class="line">app.use(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  req.secret = <span class="string">'asdfghjkl'</span>;</span><br><span class="line">  res.cookie(<span class="string">'user1'</span>, <span class="string">'zs'</span>, &#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">maxAge</span>: <span class="number">30</span>*<span class="number">24</span>*<span class="number">1000</span>&#125;); <span class="comment">// 设置cookie</span></span><br><span class="line">  res.cookie(<span class="string">'user2'</span>, <span class="string">'ls'</span>, &#123;<span class="attr">signed</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="comment">// res.clearCookie('user1'); // 删除cookie</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'签名cookie'</span>, req.signedCookies); <span class="comment">// cookie-parser的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'无签名cookie'</span>, req.cookies); <span class="comment">// cookie-parser的方法</span></span><br><span class="line">  res.send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure><ul><li>cookie-session，处理session</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieSession=<span class="built_in">require</span>(<span class="string">'cookie-session'</span>);</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(cookieSession(&#123;</span><br><span class="line">  name: <span class="string">'sessionId'</span>, <span class="comment">// 默认为session</span></span><br><span class="line">  keys: [<span class="string">'key1'</span>, <span class="string">'key2'</span>, <span class="string">'key3'</span>],</span><br><span class="line">  maxAge: <span class="number">2</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 2 hours</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!req.session.count) &#123;</span><br><span class="line">    req.session.count = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.count += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(req.session);</span><br><span class="line">  <span class="comment">// req.session.count = null;</span></span><br><span class="line">  <span class="comment">// delete req.session.count;</span></span><br><span class="line">  res.send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure><ul><li>multer，处理文件上传</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> multer  = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123; <span class="attr">dest</span>: <span class="string">'uploads'</span> &#125;); <span class="comment">// 指定上传目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定接受文件，这里指定的是后面都能用的，也可在每个接口中单独指定</span></span><br><span class="line">app.use(upload.any()); <span class="comment">// 接受任何文件</span></span><br><span class="line"><span class="comment">// app.use(upload.single('avatar')); // 只接受name属性为avatar的文件</span></span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/upload'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> fileObj = req.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newName = fileObj.path + path.parse(fileObj.originalname).ext;</span><br><span class="line">  fs.rename(fileObj.path, newName, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) res.send(<span class="string">'upload fail'</span>);</span><br><span class="line">    res.send(<span class="string">'upload success'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure><p>新建public/upload.html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"avatar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>express推荐的是jade模板，可以自定义使用哪种模板引擎。</p><ul><li><a href="http://aui.github.io/art-template/zh-cn/docs/index.html" target="_blank" rel="noopener">art-template</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">'art-template'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置模板的路径</span></span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line"><span class="comment">// 设置模板引擎</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'art'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使express兼容art-template模板引擎</span></span><br><span class="line">app.engine(<span class="string">'art'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/list'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = &#123;</span><br><span class="line">        title: <span class="string">'水果'</span>,</span><br><span class="line">        list: [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数一：模板名称：参数二：渲染模板的数据</span></span><br><span class="line">    res.render(<span class="string">'list'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>ejs</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置模板的路径</span></span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line"><span class="comment">// 设置模板引擎</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'html'</span>, ejs.renderFile);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/index'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'index.ejs'</span>, &#123;<span class="attr">name</span>: <span class="string">'zhangsan'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>使用consolidate整合模板引擎</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> cons = <span class="built_in">require</span>(<span class="string">'consolidate'</span>);</span><br><span class="line"><span class="comment">// 不需要引入ejs，但是需要安装</span></span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>);</span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line">app.engine(<span class="string">'html'</span>, cons.ejs);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/index'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'index.ejs'</span>, &#123;<span class="attr">name</span>: <span class="string">'zhangsan'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="nodejs" scheme="http://qyhever.top/categories/nodejs/"/>
    
      <category term="express" scheme="http://qyhever.top/categories/nodejs/express/"/>
    
    
      <category term="express" scheme="http://qyhever.top/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>nodejs基本操作</title>
    <link href="http://qyhever.top/2018/02/02/nodejs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://qyhever.top/2018/02/02/nodejs基本操作/</id>
    <published>2018-02-02T11:52:19.000Z</published>
    <updated>2018-06-29T14:31:08.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </li><li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 </li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">中文网</a></li></ul><h5 id="Node的优缺点"><a href="#Node的优缺点" class="headerlink" title="Node的优缺点"></a>Node的优缺点</h5><ul><li>优点<ul><li>适合高并发、I/O密集型应用（如聊天室、表单收集）</li><li>统一语言，有问题可以从前端一直追到数据库</li></ul></li><li>缺点<ul><li>不适合CPU使用率较重、I/O较少的应用（视频编码、人工智能等）</li><li>不适合计算较多的应用</li></ul></li></ul><h2 id="常用模块API"><a href="#常用模块API" class="headerlink" title="常用模块API"></a>常用模块API</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>本质上是字节数组，Node处理二进制数据的一个API。Node原生提供的全局对象，可以直接使用，不需要<code>require(&#39;buffer&#39;)</code>。</p><ol><li>Buffer实例化<ul><li><code>Buffer.alloc(size)</code></li><li><code>Buffer.alloc(string)</code></li><li><code>Buffer.from(array)</code></li><li><code>Buffer.from(string)</code></li></ul></li><li>Buffer静态方法<ul><li><code>Buffer.isEncoding()</code> ：判断是否支持该编码</li><li><code>Buffer.isBuffer()</code>：判断是否为Buffer</li><li><code>Buffer.byteLength()</code>：返回指定编码的字节长度，默认为utf-8</li><li><code>Buffer.concat()</code>：将多个Buffer对象合并为一个Buffer</li></ul></li><li>Buffer 实例方法<ul><li><code>write()</code>：向Buffer中写入内容</li><li><code>slice()</code>：截取，与字符串的<code>slice()</code>方法使用相同</li><li><code>toString()</code>：把Buffer转换成字符串</li></ul></li></ol><h3 id="路径操作-path"><a href="#路径操作-path" class="headerlink" title="路径操作 path"></a>路径操作 path</h3><p>windows是右斜杠，Linux是左斜杠</p><p>path模块，需要引入<code>const path = require(&#39;path&#39;);</code></p><ol><li><code>path.basename()</code> ：返回路径中的最后一部分，即文件名称</li><li><code>path.dirname()</code> ：获取路径</li><li><code>path.extname()</code>： 获取扩展名称</li><li><p>路径的格式化处理</p><ul><li><p><code>path.format()</code> ：obj -&gt;string</p></li><li><p><code>path.parse()</code> ：string -&gt; obj</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.parse(<span class="string">'/home/user/dir/file.txt'</span>);</span><br><span class="line"><span class="comment">// 返回:</span></span><br><span class="line"><span class="comment">// &#123; root: '/',</span></span><br><span class="line"><span class="comment">//   dir: '/home/user/dir',</span></span><br><span class="line"><span class="comment">//   base: 'file.txt',</span></span><br><span class="line"><span class="comment">//   ext: '.txt',</span></span><br><span class="line"><span class="comment">//   name: 'file' &#125;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><code>path.isAbsolute()</code>：  判断是否为绝对路径</li><li><code>path.join( pathstring1,pathstring2... )</code>  ：拼接路径，在连接路径的时候会格式化路径，进行解析</li><li><code>path.normalize( pathstring )</code> ：规范化路径</li><li><code>path.relative( pathstring1,pathstring2 )</code> ：计算相对路径</li><li><code>path.resolve()</code> ：把一个路径或路径片段的序列解析为一个绝对路径</li><li>两个特殊属性<ul><li><code>path.delimiter</code>  ：路径分隔符（windows是\,Linux是/）</li><li><code>path.sep</code>  ：环境变量分隔符（windows是; Linux是:）</li></ul></li></ol><p><strong><code>path.join()</code>与<code>path.resolve()</code>的区别：</strong></p><ul><li><p>对于<code>/</code>，<code>join</code>也会进行拼接，而<code>resolve</code>则会解析为根目录（在此之前的路径将会被丢弃）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'./foo'</span>, <span class="string">'/bar'</span>); <span class="comment">// foo/bar</span></span><br><span class="line">path.resolve(<span class="string">'./foo'</span>, <span class="string">'/bar'</span>); <span class="comment">// C:/bar</span></span><br></pre></td></tr></table></figure></li><li><p><code>resolve</code>总会返回一个相对于当前目录的绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'./foo'</span>, <span class="string">'./bar'</span>); <span class="comment">// foo/bar</span></span><br><span class="line">path.resolve(<span class="string">'./foo'</span>, <span class="string">'./bar'</span>); <span class="comment">// C:/Users/username/projectName/foo/bar</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="文件操作-FilsSystem"><a href="#文件操作-FilsSystem" class="headerlink" title="文件操作 FilsSystem"></a>文件操作 FilsSystem</h3><p>基本上每个api都有同步和异步的，追求代码简洁使用同步，追求性能使用异步。</p><ol><li><p>查看文件状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">'./data.txt'</span>, (err, stat) =&gt; &#123;</span><br><span class="line">  <span class="comment">// node约定，第一个参数为错误对象</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(stat);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*stat对象中几个重要的属性：</span></span><br><span class="line"><span class="comment">atime 访问时间</span></span><br><span class="line"><span class="comment">ctime 文件的状态信息发生变化的时间（比如文件的权限）</span></span><br><span class="line"><span class="comment">mtime 文件数据发生变化的时间</span></span><br><span class="line"><span class="comment">birthtime 文件创建时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">let</span> stat = fs.statSync(<span class="string">'./data.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stat);</span><br></pre></td></tr></table></figure></li><li><p>读文件操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有第二个参数并且是编码，那么回调函数获取到的data就是Buffer</span></span><br><span class="line">fs.readFile(<span class="string">'./data.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString()); <span class="comment">// 调用Buffer的toString()转为字符串后，才能查看</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第二个参数传入'utfw'，那么回调函数获取到的data就是字符串</span></span><br><span class="line">fs.readFile(<span class="string">'./data.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">let</span> fileData = fs.readFileSync(<span class="string">'./data.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fileData);</span><br></pre></td></tr></table></figure></li><li><p>写文件操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> content = <span class="string">'abc'</span>; <span class="comment">// 字符串</span></span><br><span class="line"><span class="comment">// let content = Buffer.from('hello'); // Buffer</span></span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'./data.txt'</span>, content, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'write success'</span>);</span><br><span class="line">  <span class="comment">// 多次写入用回调方式</span></span><br><span class="line">  <span class="comment">// fs.writeFile...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line">fs.writeFileSync(<span class="string">'./data.txt'</span>, content);</span><br></pre></td></tr></table></figure></li><li><p>文件拷贝</p><ol><li><p>同步写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dist</span>) </span>&#123;</span><br><span class="line">  fs.writeFileSync(dist, fs.readFileSync(src));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">  copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// main函数 接受源文件路径与目标文件路径两个参数</span></span><br><span class="line"><span class="comment">// use eg：node xxx.js ../source/test.html ./source/test.html</span></span><br></pre></td></tr></table></figure><blockquote><p>process是一个全局变量，可通过process.argv获得命令行参数。argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径。因此应该从命令行参数从argv[2]这个位置开始</p></blockquote></li><li><p>异步写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dist</span>) </span>&#123;</span><br><span class="line">  fs.readFile(src, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'readFile fail'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.writeFile(dist, content, (err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'writeFile fail'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'copy success'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">  copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li><li><p>流式操作</p><p>数据流：一边读取一边处理更加高效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dist</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reader = fs.createReadStream(src);</span><br><span class="line">  <span class="keyword">const</span> writer = fs.createWriteStream(dist);</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  reader.on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">    n++;</span><br><span class="line">    writer.write(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  reader.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    writer.end();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件被处理了'</span> + n + <span class="string">'次'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">  copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>使用<code>pipe()</code>简洁写法，使用<code>pipe()</code>更安全，不会出现缓存爆仓情况</p><ul><li><p><code>fs.createReadStream()</code>创建一个源文件的只读数据流</p></li><li><p><code>fs.createWriteStream()</code>创建一个目标文件的只写数据流</p></li><li><p>用<code>pipe()</code>方法把两个数据流连接起来</p><p>抽象的来说，水顺着水管从一个桶流到了另一个桶</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dist</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把 可读流 流到 可写流</span></span><br><span class="line">  fs.createReadStream(src).pipe( fs.createWriteStream(dist) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">  copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li></ul><p>模拟<code>pipe()</code>内部实现方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dist</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reader = fs.createReadStream(src);</span><br><span class="line">  <span class="keyword">let</span> writer = fs.createWriteStream(dist);</span><br><span class="line"></span><br><span class="line">  reader.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (writer.write(chunk) === <span class="literal">false</span>) &#123; <span class="comment">// 当前这块数据没有写入目标，先暂停</span></span><br><span class="line">      readr.pause();</span><br><span class="line">    &#125;</span><br><span class="line">    writer.write(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  reader.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    writer.end();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// drain()事件，只读流已经写入目标事件</span></span><br><span class="line">  writer.on(<span class="string">'drain'</span>, () =&gt; &#123;</span><br><span class="line">    reader.resume(); <span class="comment">// 可以传入下一个待写数据了</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>目录操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目录操作</span></span><br><span class="line"><span class="comment">1、创建目录</span></span><br><span class="line"><span class="comment">fs.mkdir(path[, mode], callback)</span></span><br><span class="line"><span class="comment">fs.mkdirSync(path[, mode])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、读取目录</span></span><br><span class="line"><span class="comment">fs.readdir(path[, options], callback)</span></span><br><span class="line"><span class="comment">fs.readdirSync(path[, options])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、删除目录</span></span><br><span class="line"><span class="comment">fs.rmdir(path, callback)</span></span><br><span class="line"><span class="comment">fs.rmdirSync(path)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./abc'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'create dir success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同步写法</span></span><br><span class="line">fs.mkdirSync(<span class="string">'./def'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录</span></span><br><span class="line">fs.readdir(__dirname, (err, files) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(files); <span class="comment">// 读取的files是文件和目录的数组集合</span></span><br><span class="line">  files.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.stat(path.join(__dirname, item), (err, stat) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (stat.isFile()) &#123;</span><br><span class="line">        conosle.log(<span class="string">'文件'</span>, item);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'目录'</span>, item);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同步写法</span></span><br><span class="line"><span class="keyword">let</span> files = fs.readdirSync(__dirname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line">fs.rmdir(<span class="string">'./abc'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'remove dir success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步写法</span></span><br><span class="line">fs.rmdirSync(<span class="string">'./def'</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Web开发概述"><a href="#Web开发概述" class="headerlink" title="Web开发概述"></a>Web开发概述</h3><ul><li><p>传统的动态网站开发需要应用软件</p><p>PHP ： Apache + php模块<br>java ：Tomcat 、Weblogic<br>Node.js  : 不需要应用软件（自己有相应的模块）</p></li></ul><h3 id="服务器功能-http"><a href="#服务器功能-http" class="headerlink" title="服务器功能 http"></a>服务器功能 http</h3><ol><li><p>初步实现服务器功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器实例对象</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定请求事件</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，不写默认80端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>运行上面文件，浏览器访问<code>localhost:3000</code>即可看到<code>ok</code>，下面是简洁写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>处理路径的分发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">处理路径的分发</span></span><br><span class="line"><span class="comment">localhost:3000/index.html,</span></span><br><span class="line"><span class="comment">localhost:3000/about.html,</span></span><br><span class="line"><span class="comment">访问不同的路径，返回的内容应该不相同</span></span><br><span class="line"><span class="comment">1、req对象是Class: http.IncomingMessage的实例对象</span></span><br><span class="line"><span class="comment">2、res对象是Class: http.ServerResponse的实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url.startsWith(<span class="string">'/index'</span>)) &#123;</span><br><span class="line">    res.write(<span class="string">'welcome\n'</span>);</span><br><span class="line">    res.write(<span class="string">'to\n'</span>);</span><br><span class="line">    res.end(<span class="string">'index'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">'/about'</span>)) &#123;</span><br><span class="line">    res.end(<span class="string">'about'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'404'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li><p>响应完整的页面信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装读文件并返回客户端的操作</span></span><br><span class="line"><span class="keyword">let</span> readFile = <span class="function">(<span class="params">filename, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname, <span class="string">'public'</span>, filename), <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url.startsWith(<span class="string">'/index'</span>)) &#123;</span><br><span class="line">    readFile(<span class="string">'index.html'</span>, res);</span><br><span class="line">  &#125; <span class="keyword">else</span> (req.url.startsWith(<span class="string">'/about'</span>)) &#123;</span><br><span class="line">    readFile(<span class="string">'about.html'</span>, res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain; charset=utf8'</span> &#125;);</span><br><span class="line">    res.end(<span class="string">'404 Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li><p>根据不同的文件后缀返回不同响应格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'./mime.json'</span>); <span class="comment">// mime.json文件是文件后缀对应的响应格式</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname, <span class="string">'public'</span>, req.url), (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">let</span> defaultResType = <span class="string">'text/html'</span>;</span><br><span class="line">    <span class="comment">// 获取请求文件的后缀</span></span><br><span class="line">    <span class="keyword">let</span> ext = path.extname(req.url);</span><br><span class="line">    <span class="comment">// 如果存在这种后缀对应的响应格式，就覆盖默认的</span></span><br><span class="line">    <span class="keyword">if</span> (mime[ext]) &#123;</span><br><span class="line">      defaultResType = mime[ext];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果响应的内容是文本，就设置utf8编码</span></span><br><span class="line">    <span class="keyword">if</span> (defaultResType.startsWith(<span class="string">'text'</span>)) &#123;</span><br><span class="line">      defaultResType += <span class="string">'; charset=utf8'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: defaultResType &#125;);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>重写上面代码（功能分离）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// staticReq.js文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'./mime.json'</span>);</span><br><span class="line"><span class="comment">// 封装静态服务请求的函数，导出</span></span><br><span class="line">exports.staticServer = <span class="function">(<span class="params">req, res, root</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(path.join(root, req.url), (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">let</span> defaultResType = <span class="string">'text/html'</span>;</span><br><span class="line">    <span class="comment">// 获取请求文件的后缀</span></span><br><span class="line">    <span class="keyword">let</span> ext = path.extname(req.url);</span><br><span class="line">    <span class="comment">// 如果存在这种后缀对应的响应格式，就覆盖默认的</span></span><br><span class="line">    <span class="keyword">if</span> (mime[ext]) &#123;</span><br><span class="line">      defaultResType = mime[ext];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果响应的内容是文本，就设置utf8编码</span></span><br><span class="line">    <span class="keyword">if</span> (defaultResType.startsWith(<span class="string">'text'</span>)) &#123;</span><br><span class="line">      defaultResType += <span class="string">'; charset=utf8'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: defaultResType &#125;);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> staticService = <span class="built_in">require</span>(<span class="string">'./staticReq.js'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  staticService(req, res, path.join(__dirname, <span class="string">'public'</span>));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li><p>服务器主动发送请求，请求数据</p><p>把<code>res</code>对象当做一个只读数据流来访问响应数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求豆瓣接口</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.get(<span class="string">'http://api.douban.com/v2/movie/coming_soon'</span>, (res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">''</span>;</span><br><span class="line">  res.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    content += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(content));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​</p><ul><li>简单爬虫功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：发送请求爬取到百度的首页内容，输出到本地的baidu.html下面</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  hostname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> req = http.request(options, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">''</span>;</span><br><span class="line">  res.on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">    content += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    fs.writeFile(path.join(__dirname, <span class="string">'baidu.html'</span>), content, (error) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure><ul><li>接口包装</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器获取到天气信息，暴露一个接口给客户端调用</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cityCode = <span class="string">'101010300'</span>; <span class="comment">// 北京</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  host: <span class="string">'www.weather.com.cn'</span>,</span><br><span class="line">  port: <span class="number">80</span>,</span><br><span class="line">  path: <span class="string">`/data/sk/<span class="subst">$&#123;cityCode&#125;</span>.html`</span></span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">'/weather'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> req = http.request(options, res =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">''</span>;</span><br><span class="line">    res.on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">      content += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(content);</span><br><span class="line">      response.end(content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  req.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="不同请求方式的参数处理"><a href="#不同请求方式的参数处理" class="headerlink" title="不同请求方式的参数处理"></a>不同请求方式的参数处理</h3><ol><li><p><code>url</code>模块：解析请求路径，解析URL、生成URL，以及拼接URL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不一定需要传递完整的URL</span></span><br><span class="line"><span class="keyword">let</span> src = <span class="string">'http://www.baidu.com/aaa/bbb?username=tom&amp;password=123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = url.parse(src, <span class="literal">true</span>); <span class="comment">// 第二个参数传入true，可以把参数转换为对象形式</span></span><br><span class="line"><span class="built_in">console</span>.log(ret);</span><br><span class="line"><span class="comment">/*Url &#123;</span></span><br><span class="line"><span class="comment">  protocol: 'http:',</span></span><br><span class="line"><span class="comment">  slashes: true,</span></span><br><span class="line"><span class="comment">  auth: null,</span></span><br><span class="line"><span class="comment">  host: 'www.baidu.com',</span></span><br><span class="line"><span class="comment">  port: null,</span></span><br><span class="line"><span class="comment">  hostname: 'www.baidu.com',</span></span><br><span class="line"><span class="comment">  hash: null,</span></span><br><span class="line"><span class="comment">  search: '?username=tom&amp;password=123',</span></span><br><span class="line"><span class="comment">  query: &#123; username: 'tom', password: '123' &#125;,</span></span><br><span class="line"><span class="comment">  pathname: '/aaa/bbb',</span></span><br><span class="line"><span class="comment">  path: '/aaa/bbb?username=tom&amp;password=123',</span></span><br><span class="line"><span class="comment">  href: 'http://www.baidu.com/aaa/bbb?username=tom&amp;password=123' &#125;*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>get</code>请求参数处理，<code>get</code>请求通过地址栏传参，因此可以使用<code>url</code>模块来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// url.parse方法加上req.url属性是处理HTTP请求的固定搭配</span></span><br><span class="line">  <span class="keyword">let</span> getParam = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line">  <span class="built_in">console</span>.log(getParam);</span><br><span class="line">  res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>post</code>请求参数处理，通常使用<code>querystring</code>模块处理，<code>querystring.parse()</code>方法可以把形如<code>username=tom&amp;password=123</code>这种URL参数字符串转换为参数对象</p><p>在node中，<code>post</code>请求接收响应数据是分段接收的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url.startsWith(<span class="string">'/login'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> postData = <span class="string">''</span>;</span><br><span class="line">    req.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">      postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> postParam = querystring.parse(postData);</span><br><span class="line">      <span class="built_in">console</span>.log(postParam);</span><br><span class="line">      res.end(<span class="string">'ok'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ol><p>上面使用 += 来拼接数据流，这个过程包含了一个隐式转换。接受的是 Buffer，postData += chunk相当于 postData += chunk.toString()。优化的做法是使用数组来收集 Buffer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">req.on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">  data.push(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> buf = Buffer.concat(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="nodejs" scheme="http://qyhever.top/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="http://qyhever.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>常见的跨域解决方式</title>
    <link href="http://qyhever.top/2018/01/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://qyhever.top/2018/01/13/常见的跨域解决方式/</id>
    <published>2018-01-13T13:28:46.000Z</published>
    <updated>2018-06-20T13:30:25.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>现在很多公司都是前后端分离，跨域是经常遇到的一个问题，面试中也是经常问到，在这里总结一下现在常用的几种方式。</p></blockquote><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><ol><li>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。</li><li>域名，端口，协议不同，都会造成跨域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://www.123.com/index.html 调用 http://www.123.com/server.PHP （非跨域）</span><br><span class="line">http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）</span><br><span class="line">http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）</span><br><span class="line">http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）</span><br><span class="line">http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）</span><br><span class="line">注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</span><br></pre></td></tr></table></figure><h2 id="跨域的解决方式"><a href="#跨域的解决方式" class="headerlink" title="跨域的解决方式"></a>跨域的解决方式</h2><h3 id="jsonp跨域"><a href="#jsonp跨域" class="headerlink" title="jsonp跨域"></a>jsonp跨域</h3><p>jsonp跨域其实也是JavaScript设计模式中的一种代理模式。html中的标签请求不同域名下的资源是被允许的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- img  src可以指向一个跨域的资源</span><br><span class="line">- link</span><br><span class="line">- script</span><br></pre></td></tr></table></figure><p>使用jsonp，一般是动态创建script标签，将它的src指向一个带参网址，因为script标签的src属性不存在跨域，从而实现跨域通信。</p><ul><li>前端jsonp处理<ul><li>写好请求成功的回调函数(回调函数里面是处理逻辑)，函数定义好了但是没有调用</li><li>创建script标签</li><li>设置script标签的src属性为接口路径</li><li>将script标签插入到dom中</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://api.douban.com/v2/movie/top250?callback=cb'</span>;</span><br><span class="line"><span class="built_in">window</span>[<span class="string">'cb'</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><ul><li>后端处理</li></ul><p>后端获取传过去的回调函数名，返回函数调用，把数据放在函数参数里面</p><p>jQuery里面把jsonp请求封装成了ajax方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'http://api.douban.com/v2/movie/top250'</span>,</span><br><span class="line">  type: <span class="string">'get'</span>,</span><br><span class="line">  data: &#123;<span class="attr">count</span>: <span class="number">20</span>, <span class="attr">start</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">  jsonp: <span class="string">'callback'</span>, <span class="comment">// 自定义参数名字 callback=cb</span></span><br><span class="line">  jsonpCallback: <span class="string">'cb'</span>, <span class="comment">// 自定义回调函数名字 callback=cb</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>只支持get请求</li><li>必须保证加载的顺序</li><li>不方便通过程序传递参数</li></ul><h3 id="CORS（跨资源共享）"><a href="#CORS（跨资源共享）" class="headerlink" title="CORS（跨资源共享）"></a>CORS（跨资源共享）</h3><p>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访问于包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。</p><p>CORS（Cross Origin Resource Sharing）是W3C的一个工作草案，定义了在必须访问跨域资源时，浏览器域服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是失败。</p><p>一个简单的请求，没有自定义的头部，主体内容为text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给与响应。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http: api.douban.com</span><br></pre></td></tr></table></figure><p>如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发 * ）。</p><p>php示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 1、某个域名可以访问</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Origin: http://localhost:8080'</span>);</span><br><span class="line"><span class="comment">// 2、任意域名允许访问</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br><span class="line"><span class="comment">// 响应类型，多个方法以逗号分隔，可不设置，特殊请求必需</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Methods: POST'</span>);</span><br><span class="line"><span class="comment">// 响应头信息，多个头部以逗号分隔，可不设置，特殊请求必需</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Headers: x-requested-with,contype-type'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'success'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。对于前端开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息。</p><p>CORS比jsonp更强大，可以支持所有类型的http请求，但是IE10以下不兼容。jsonp可以实现老版本浏览器的跨域。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>配置 apache 服务器来实现 url 映射解决 跨域问题，调用本地服务器数据的时候, 通过地址映射, 直接访问的就是远程服务器的数据。</p><p>配置httpd.conf文件和httpd-vhosts.conf文件</p><ol><li><p>找到 httpd.conf 文件</p></li><li><p>找到里面的 proxy_module 模块与 proxy_http_module 模块, 将其注释去掉</p></li><li><p>在httpd-vhosts.conf找到要配置的虚拟主机</p></li><li><p>在里面添加两段代码</p><p>ProxyRequests Off<br>ProxyPass /aaa <a href="http://api.douban.com" target="_blank" rel="noopener">http://api.douban.com</a></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;E:/xampp/htdocs/aaa&quot;</span><br><span class="line">    ServerName aaa.com</span><br><span class="line">    ServerAlias www.aaa.com</span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPass /aaa http://api.douban.com</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>这样就将<a href="http://api.douban.com地址映射到了/aaa。" target="_blank" rel="noopener">http://api.douban.com地址映射到了/aaa。</a></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#proxy config</span><br><span class="line">location /douban &#123;</span><br><span class="line">    rewrite ^.+<span class="regexp">/douban/</span>?(.*)$ /$<span class="number">1</span> <span class="keyword">break</span>;</span><br><span class="line">    proxy_pass http:<span class="comment">//api.douban.com/v2/movie;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>/douban</code></li></ol><p>是一个匹配规则，用于拦截请求，匹配任何以 /api开头的地址，匹配符合以后，停止往下搜索正则</p><ol><li><code>rewrite ^.+/douban/?(.*)$ /$1 break;</code></li></ol><p>重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用</p><ol><li><code>proxy_pass</code></li></ol><p>把请求代理到其他主机</p><h4 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h4><p>使用node中间件实现代理跨域，通过node启动一个代理服务器，实现数据的转发。</p><p>使用express + http-proxy-middleware：</p><p>前端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 浏览器是否读写cookie</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://localhost:3000/movie/top250'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">400</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/movie'</span>, pxory(&#123;</span><br><span class="line">  <span class="comment">// 代理跨域目标接口 http://api.douban.com/v2/movie/top250</span></span><br><span class="line">  target: <span class="string">'http://api.douban.com/v2'</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">  onProxyRes: <span class="function"><span class="keyword">function</span> (<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:10080'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">  cookieDomainRewrite: <span class="string">'localhost'</span> <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参考文档:</p><p><a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">https://juejin.im/post/5a2f92c65188253e2470f16d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端开发" scheme="http://qyhever.top/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端开发" scheme="http://qyhever.top/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>css中居中的n种方法</title>
    <link href="http://qyhever.top/2018/01/09/css%E4%B8%AD%E5%B1%85%E4%B8%AD%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://qyhever.top/2018/01/09/css中居中的n种方法/</id>
    <published>2018-01-09T13:00:31.000Z</published>
    <updated>2018-06-20T13:30:25.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于居中布局"><a href="#关于居中布局" class="headerlink" title="关于居中布局"></a>关于居中布局</h2><p>在开发过程中，很多时候需要元素居中。css中实现居中不困难，有很多种方法可以实现居中效果，但在实际开发中，还是根据需求来选择。</p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>适用于行内元素和行内块元素，例如文本，链接，图片，只需在父元素中使用<code>text-align:center</code></p><h3 id="margin-定宽"><a href="#margin-定宽" class="headerlink" title="margin + 定宽"></a>margin + 定宽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .child &#123;</span></span><br><span class="line"><span class="undefined">    width: 100px;</span></span><br><span class="line"><span class="undefined">    margin: 0 auto;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>适用于块级元素，子元素设置<code>margin-left</code>和<code>margin-right</code>为<code>auto</code>（子元素一定要设置宽度）</p><h3 id="table-margin"><a href="#table-margin" class="headerlink" title="table + margin"></a>table + margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .child &#123;    </span></span><br><span class="line"><span class="undefined">    display: table;    </span></span><br><span class="line"><span class="undefined">    margin: 0 auto;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>display:table</code>在表现上类似<code>block</code>元素，子元素如果不设置宽度，即为内容宽度</p><h3 id="absolute-margin-left"><a href="#absolute-margin-left" class="headerlink" title="absolute + margin-left"></a>absolute + margin-left</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;  </span></span><br><span class="line"><span class="undefined">  .child &#123;    </span></span><br><span class="line"><span class="undefined">    position: absolute;    </span></span><br><span class="line"><span class="undefined">    left: 50%;    </span></span><br><span class="line"><span class="undefined">    width: 100px;    </span></span><br><span class="line"><span class="undefined">    margin-left: -50px;  /* width/2 */</span></span><br><span class="line"><span class="undefined">  &#125;  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素宽度固定，设置margin-left为它的宽度的一半的负值，兼容性好</p><h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;  </span></span><br><span class="line"><span class="undefined">  .child &#123;    </span></span><br><span class="line"><span class="undefined">    position: absolute;    </span></span><br><span class="line"><span class="undefined">    left: 50%;    </span></span><br><span class="line"><span class="undefined">    transform: translateX(-50%);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绝对定位脱离文档流，不会对后续元素的布局造成影响。<code>transform</code>为 CSS3 属性，有兼容性问题</p><h3 id="flex-justify-content"><a href="#flex-justify-content" class="headerlink" title="flex + justify-content"></a>flex + justify-content</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    display: flex;    </span></span><br><span class="line"><span class="undefined">    justify-content: center;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置父元素为伸缩盒子，justify-content设置子元素在主轴上的对齐方式，兼容性差</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  img &#123;</span></span><br><span class="line"><span class="undefined">vertical-align: middle;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当一个行内块元素和一段文本水平排列时，可以设置行内块元素<code>vertical-align:middle</code>，让文本垂直居中</p><h3 id="height-line-height"><a href="#height-line-height" class="headerlink" title="height = line-height"></a>height = line-height</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>text<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">height: 60px;</span></span><br><span class="line"><span class="undefined">line-height: 60px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父元素设置行高等于高，文本可以垂直居中，只适用于单行文本</p><h3 id="padding-top-padding-bottom"><a href="#padding-top-padding-bottom" class="headerlink" title="padding-top = padding-bottom"></a>padding-top = padding-bottom</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>text<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">padding: 100px 0;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置父元素上下padding值相等</p><h3 id="table-vertical-align"><a href="#table-vertical-align" class="headerlink" title="table + vertical-align"></a>table + vertical-align</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">display: table-cell;</span></span><br><span class="line"><span class="undefined">vertical-align: middle;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素宽高不固定，父元素设置<code>display:table-cell</code>后对margin值不响应，内容溢出时会自动撑开父元素，兼容性好</p><h3 id="absolute-margin"><a href="#absolute-margin" class="headerlink" title="absolute + margin"></a>absolute + margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;  </span></span><br><span class="line"><span class="undefined">  .child &#123;    </span></span><br><span class="line"><span class="undefined">    position: absolute;    </span></span><br><span class="line"><span class="undefined">    top: 50%;</span></span><br><span class="line"><span class="undefined">    margin-top: -100px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素定高，绝对定位后margin-top=子元素高度的一半负值</p><h3 id="absolute-transform-1"><a href="#absolute-transform-1" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;  </span></span><br><span class="line"><span class="undefined">  .child &#123;    </span></span><br><span class="line"><span class="undefined">    position: absolute;    </span></span><br><span class="line"><span class="undefined">    top: 50%;</span></span><br><span class="line"><span class="undefined">    transform: translateY(-50%);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素不定高度，css3有兼容性问题</p><h3 id="flex-align-items"><a href="#flex-align-items" class="headerlink" title="flex + align-items"></a>flex + align-items</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;    </span></span><br><span class="line"><span class="undefined">    display: flex;    </span></span><br><span class="line"><span class="undefined">    align-items: center;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父元素为伸缩盒子，子元素不定高，设置子元素在侧轴上的对齐方式，也可以设置子元素的<code>align-self: center</code></p><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="absolute-margin-1"><a href="#absolute-margin-1" class="headerlink" title="absolute + margin"></a>absolute + margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .child &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    top: 50%;</span></span><br><span class="line"><span class="undefined">    left: 50%;</span></span><br><span class="line"><span class="undefined">    margin-top: -100px;</span></span><br><span class="line"><span class="undefined">    margin-left: -100px;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 子元素绝对定位，margin负值盒子一半，子元素需固定宽高，兼容性好</p><h3 id="absolute-transform-2"><a href="#absolute-transform-2" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .child &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    top: 50%;</span></span><br><span class="line"><span class="undefined">    left: 50%;</span></span><br><span class="line"><span class="undefined">    transform: translate(-50%, -50%);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素绝对定位，使用css3的transform属性，子元素不定宽高，兼容性不好</p><h3 id="table-cell-text-align-vertical-align"><a href="#table-cell-text-align-vertical-align" class="headerlink" title="table-cell + text-align + vertical-align"></a>table-cell + text-align + vertical-align</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">    display: table-cell;</span></span><br><span class="line"><span class="undefined">    vertical-align: middle;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .child &#123;</span></span><br><span class="line"><span class="undefined">    display: inline-block;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素不定宽高，子元素需设置为行内块，兼容性好</p><h3 id="flex-justify-content-align-items"><a href="#flex-justify-content-align-items" class="headerlink" title="flex + justify-content + align-items"></a>flex + justify-content + align-items</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">    display: flex;</span></span><br><span class="line"><span class="undefined">    justify-content: center;</span></span><br><span class="line"><span class="undefined">    align-items: center;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码简洁，子元素不定宽高，兼容性不好</p><h3 id="absolute-四个方向都为0-margin"><a href="#absolute-四个方向都为0-margin" class="headerlink" title="absolute + 四个方向都为0 + margin"></a>absolute + 四个方向都为0 + margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .parent &#123;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  /* 自绝父相，子盒子定位都为0，margin：auto  */</span></span><br><span class="line"><span class="undefined">  .child &#123;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    right: 0;</span></span><br><span class="line"><span class="undefined">    bottom: 0;</span></span><br><span class="line"><span class="undefined">    margin: auto;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素绝对定位，固定宽高，四个方向定位都为0，设置margin:auto</p><p>css中居中的方法还用很多，根据实际场景选择合适的方法就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="css" scheme="http://qyhever.top/categories/css/"/>
    
    
      <category term="css" scheme="http://qyhever.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js中的闭包</title>
    <link href="http://qyhever.top/2018/01/05/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://qyhever.top/2018/01/05/js中的闭包/</id>
    <published>2018-01-05T08:40:42.000Z</published>
    <updated>2018-06-20T13:30:25.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>从字面意思来理解，就是把一些私有变量封闭起来，使其他程序访问不到，同时把这个封闭的空间打包丢出来，提供一个接口可以使用这个包。</p><p>高级程序设计 第3版 中的描述：<strong>闭包是指有权访问另一个函数作用域中的变量的函数</strong></p><p>JavaScript权威指南 第6版 中的描述：<strong>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 闭包</strong></p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>使用闭包主要是为了设计私有的方法和变量。</p><ul><li>把代码封闭起来，避免全局作用域的污染</li><li>可以保存一些私有变量，然后安全的通过接口访问函数内部的变量</li><li>私有变量的值始终保存在内存中</li></ul><h2 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h2><ul><li>函数嵌套函数</li><li>函数内部可以使用外部的参数和变量，即使外层函数已经执行完毕</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h2 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h2><p>创建闭包的方式通常是在函数内部再定义一个函数，由于作用域的关系，外部函数无法访问内部函数的变量，而内部函数可以访问外部函数的变量，此时如果外部函数将内部函数返回，便形成了闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar(); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// a是函数foo的一个局部变量，又被返回的匿名函数所使用</span></span><br></pre></td></tr></table></figure><p>上面代码中，bar其实就是一个闭包函数。foo()调用完成后，返回了一个函数，然后将这个函数赋值给了bar，然后调用bar，bar函数中没有自由变量a，就会到上层作用域去找，函数foo中的a的值为10，所以最后结果是10。</p><blockquote><p>注意：当某个函数被调用时，会创建一个执行环境。函数调用完成后，会销毁函数的执行环境，函数体中的变量也会被销毁。但是在上面代码中，foo()函数的执行环境并没用被销毁。为什么？因为foo函数返回的是一个函数，而之后又调用了这个函数，这个函数体里面用到了foo函数作用域中的变量a，这个a不能被销毁，不然就找不到了。因此foo函数始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p></blockquote><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>应用场景：</p><ol><li>使用闭包可以在JavaScript中模拟块级作用域（避免全局作用域的污染）（在ES6之前，js是没有块级作用域的）；</li><li>闭包可以用于在对象中创建私有变量。</li></ol><h5 id="做一个简单的计数器"><a href="#做一个简单的计数器" class="headerlink" title="做一个简单的计数器"></a>做一个简单的计数器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar(); <span class="comment">// 1</span></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>为什么要这样写？首先，变量n不能为全局变量，不然可能被修改，所以放在函数里面可以不受全局作用域的影响。然后，通过闭包来访问并修改这个变量，实现计数效果。</p><h5 id="现在有一个数组result，要循环加入函数，每个函数的返回值为递增，写法如下："><a href="#现在有一个数组result，要循环加入函数，每个函数的返回值为递增，写法如下：" class="headerlink" title="现在有一个数组result，要循环加入函数，每个函数的返回值为递增，写法如下："></a>现在有一个数组result，要循环加入函数，每个函数的返回值为递增，写法如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 10</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 10</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// ... 10</span></span><br></pre></td></tr></table></figure><p>表面上看是每个函数应该返回自己的索引值，但实际上，每个函数都是返回10。js单线程对回调的处理是：同步代码在执行栈中执行，而回调会放到消息队列，当同步代码执行完毕，再去调用消息队列中的回调方法。</p><p>在这里，for循环每执行一次，就会放一个回调到消息队列中排队等候，for循环执行完毕，按顺序放了10个回调函数到消息队列。执行栈中的for循环执行完成后，变量i的值为10，这时再执行回调，所以每个函数的返回值都为10了。</p><p>那么？怎么解决呢？可以创建一个匿名函数强制让闭包的行为符合预期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i);</span><br><span class="line">&#125;</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，for循环每执行一次，都会先给回调函数传参，而这个回调函数直接就调用了，返回了一个函数，函数的返回值是传递的参数。这样就实现了预期效果。</p><p>实际上，可以直接使用ES6中的let。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>ES5中的函数作用域是局部作用域，而ES6中的let语法的作用域是块级作用域，在这里就是for循环，let本质上就是形成了一个闭包，和上面创建匿名函数的写法是一个意思，因此有人说let是语法糖。</p><h5 id="setTimeout经典面试题"><a href="#setTimeout经典面试题" class="headerlink" title="setTimeout经典面试题"></a>setTimeout经典面试题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这道面试题应该都遇到过，表面上是输出0,1,2,3,4，但是却是5个5。</p><p>上面的执行过程其实是这样的，for循环先执行，每执行一次，就会放一个setTimeout回调到消息队列中排队等候，for循环执行完毕，按顺序放了5个setTimeout回调到消息队列。执行栈中的for循环执行完成后，变量i的值为5，这时再执行回调，所以每个函数输出都是5了。</p><p>解决方法还是和上道题一样，可以使用闭包，也可以使用let</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;, num * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>可以看到，使用let确实简洁了不少，这就是ES6带来的高效率啊！</p><h2 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h2><p>this的指向是在函数调用时确定的，在全局作用域中，this指向window，当函数被作为某个对象的方法调用时，this指向那个对象。匿名函数的执行环境具有全局性，因此this对象通常指向window。而在闭包中，可能不会这么明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'this is window'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'this is foo'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.getName()(); <span class="comment">// this is window</span></span><br></pre></td></tr></table></figure><p>返回的匿名函数不能直接访问外部函数getName中的this和arguments，把外部作用域的this保存在一个闭包能够访问的变量里，就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'this is window'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'this is foo'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.getName()(); <span class="comment">// this is foo</span></span><br></pre></td></tr></table></figure><p>把this赋值给了<code>_this</code>，闭包可以访问这个变量，这是在包含函数中特意声明的，而在函数返回之后，<code>_this</code>也仍然引用着foo，所以就返回了foo。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>闭包可以用来保存私有变量，这是优点也是缺点。闭包会使得函数中的变量都被保存在内存中，内存开销很大，<strong>不必要的闭包只会徒增内存消耗！</strong>解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>);</span><br><span class="line">  <span class="keyword">var</span> id = element.id;</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(id);</span><br><span class="line">  &#125;;</span><br><span class="line">  element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接使用element，包含函数的活动对象中也仍然会保存一个引用。因此，可以把element变量设置为null，这样能够解除引用，减少引用数，确保能正常回收其占用的内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包在各类库和框架中（例如jQuery）的应用非常多，理解闭包，在阅读js库源码时有很大的帮助。</p><p>闭包是JavaScript中非常重要的一部分知识，使用闭包可以大大减少我们的代码量，使我们的代码看上去更简洁，调试时候对各变量走势有更清晰认识等等。闭包比较难懂，或多或少的给初级开发人员（像我）带来许多BUG。不懂闭包这些知识，也可以开发javascript程序，但是写不出高质量、符合设计原则的javascript程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="面向对象" scheme="http://qyhever.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数绑定与函数柯里化</title>
    <link href="http://qyhever.top/2017/12/30/%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://qyhever.top/2017/12/30/函数绑定与函数柯里化/</id>
    <published>2017-12-30T09:23:44.000Z</published>
    <updated>2018-06-29T14:12:07.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><p>函数绑定是一项比较流行的高级技巧，函数绑定可以在指定的 this 环境中调用函数。该技巧通常和回调函数与事件处理程序一起使用，便于在将函数作为参数传递的同时保留其作用域。</p><p>一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler.handleClick);</span><br></pre></td></tr></table></figure><p>上面代码运行，点击打印<code>undefined</code>。这里可能有点疑惑，明明 handler.msg 是有值的。这里的问题在于 handler.handleClick 只是一个函数引用，并没有将 handler.handleClick() 的执行环境保留，导致 this 指向了 按钮 元素而不是  handler 对象。</p><p>可以使用闭包解决这个问题：</p><p>在事件触发时创建闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  handler.handleClick()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数本身返回闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context.msg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler.handleClick());</span><br></pre></td></tr></table></figure><p>另一种解决方法是函数绑定：</p><p>ES5 之后 js 原生自带 <code>bind()</code> 函数，函数对象可以直接调用 <code>bind()</code>方法，传入作为 this 值的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler.handleClick.bind(handler));</span><br></pre></td></tr></table></figure><p>实现一个简单的 <code>bind()</code>函数，接受一个函数和一个作为 this 值的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, bind(handler.handleClick, handler));</span><br></pre></td></tr></table></figure><p>jQuery 有类似 <code>bind()</code>的 <code>jQuery.proxy(function, context)</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, $.proxy(handler.handleClick, handler));</span><br></pre></td></tr></table></figure><p>如果需要函数在指定的特定环境中执行，可以使用函数绑定，这样就不用手动创建闭包了。函数绑定使用到了闭包，需要更多的内存，所以最好在必要时使用。</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数柯里化用于创建已经设置好了一个或多个参数的函数，它使用闭包返回一个函数，返回的函数需要携带传入的参数。</p><p>一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">add(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>可以看到第一个参数是固定的，这时候会很自然的想到再进行封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curriedAdd</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add(<span class="number">2</span>, n2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">curriedAdd(<span class="number">3</span>);</span><br><span class="line">curriedAdd(<span class="number">4</span>);</span><br><span class="line">curriedAdd(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>函数柯里化就是类似上面的技术，把前面固定的参数固定，返回一个更适用的新函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>curry()</code>的第一个参数是要进行柯里化的函数，其他参数是要传入的值。在 arguments 对象上调用 <code>slice()</code>方法获取第一个参数之后的所有参数，args 数组包含了来自需要柯里化的函数的参数。在返回的函数中再次获取调用新函数传递的参数，最后把参数拼接起来，使用 apply 来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 是需要柯里化的函数，返回了新函数 curriedAdd</span></span><br><span class="line"><span class="keyword">var</span> curriedAdd = curry(add, <span class="number">2</span>);</span><br><span class="line">curriedAdd(<span class="number">3</span>);</span><br><span class="line">curriedAdd(<span class="number">4</span>);</span><br><span class="line">curriedAdd(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>前面固定的参数可以不止一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n1, n2, n3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2 + n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curriedSum = curry(sum, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 固定了前两个参数</span></span><br><span class="line">curriedSum(<span class="number">10</span>);</span><br><span class="line">curriedSum(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>函数绑定与函数柯里化紧密相关，可以使用柯里化技术构造出功能更强的<code>bind()</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在前面函数绑定的例子，使用现在的<code>bind()</code>函数，可以任意传递参数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">name, event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(event.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, bind(handler.handleClick, handler, <span class="string">'tom'</span>));</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是 event 事件源参数需要放在最后才会接受到</p></blockquote><p>ES5 中的<code>bind()</code>方法也带有柯里化功能，在 this 值的后面，可以传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  msg: <span class="string">'event handle obj'</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">name, event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(event.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler.handleClick.bind(handler, <span class="string">'tom'</span>));</span><br></pre></td></tr></table></figure><p>函数柯里化的突出思想，因为固定了前面的参数，所以它降低了适用范围，但提高了适用性。</p><p>柯里化函数和绑定函数提供了强大的动态函数创建功能，可用于复杂的算法和功能。由于使用了闭包，同时也增大了内存开销。</p><p>功能虽好，可不要滥用哦！</p><p>参考：<a href="">JavaScript高级程序设计 第3版</a></p><p><a href="https://juejin.im/post/5a96481d6fb9a0633f0e4cc1" target="_blank" rel="noopener">函数柯里化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="高级函数" scheme="http://qyhever.top/tags/%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>总结数组去重的常见算法</title>
    <link href="http://qyhever.top/2017/12/14/%E6%80%BB%E7%BB%93%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://qyhever.top/2017/12/14/总结数组去重的常见算法/</id>
    <published>2017-12-14T15:40:38.000Z</published>
    <updated>2018-11-20T10:36:13.448Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开发过程中，经常会遇到数组元素重复的情况，在js中，没有内置的方法解决此类问题，需要自己去实现，下面看一下常用的几种数组去重方法。</p><h2 id="方法一-双重for循环"><a href="#方法一-双重for循环" class="headerlink" title="方法一 双重for循环"></a>方法一 双重for循环</h2><p>双重循环原理都差不多，外层循环 目标数组，内层循环 创建的临时数组，把目标数组和临时数组的每一项比较，如果相等，则进行相应处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i &lt; arrlen; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, retlen = ret.length; j &lt; retlen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === ret[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有重复元素，不会 break，j 就会和 retlen 相等，把外层循环的当前arr[i]添加到临时数组</span></span><br><span class="line">    <span class="comment">// 如果有重复元素，由于退出了循环，j 和 retlen 不会相等，不会添加</span></span><br><span class="line">    <span class="keyword">if</span> (j === retlen) &#123;</span><br><span class="line">      ret.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret= [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i &lt; arrlen; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次外层循环声明一个标记</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, retlen = ret.length; j &lt; retlen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === ret[j]) &#123;</span><br><span class="line">        <span class="comment">// 有重复元素，改变标记状态</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断标记的值来确定当前元素是否重复</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      ret.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用splice</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法会影响原数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 从当前元素的后一个开始，再往后循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arrlen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        <span class="comment">// 有重复元素，直接删除</span></span><br><span class="line">        <span class="keyword">this</span>.splice(j, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重循环思路清晰，兼容性好</p><h2 id="方法二-利用对象属性不重复的特性"><a href="#方法二-利用对象属性不重复的特性" class="headerlink" title="方法二 利用对象属性不重复的特性"></a>方法二 利用对象属性不重复的特性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [],</span><br><span class="line">      obj = &#123;&#125;,</span><br><span class="line">      item;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i &lt; arrlen; i++) &#123;</span><br><span class="line">    item = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (!obj[item]) &#123; <span class="comment">// 如果对象中没有这个元素(属性)</span></span><br><span class="line">      ret.push(item); <span class="comment">// 追加到数组中</span></span><br><span class="line">      obj[item] = <span class="number">1</span>; <span class="comment">// 把当前元素作为属性添加到对象上，下次判断有没有这个属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用的对象的属性不重复的特性，思想巧妙，此方法不能区分 1 和 “1”，这是因为对象的属性（键）实际上都是字符串，1 和 “1”，作为对象的属性（键）时，都是 “1”，要解决这个问题，可以使用 ES6 的 Map 数据结构（一种类似对象的数据结构，任意值都可以作为键）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [],</span><br><span class="line">      map = <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">      item;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i &lt; arrlen; i++) &#123;</span><br><span class="line">    item = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (!map.has(item)) &#123; <span class="comment">// 如果对象中没有这个元素(属性)</span></span><br><span class="line">      ret.push(item); <span class="comment">// 追加到数组中</span></span><br><span class="line">      map.set(item, <span class="number">1</span>); <span class="comment">// 把当前元素作为键添加到 map 中，下次判断有没有这个键</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三-使用filter"><a href="#方法三-使用filter" class="headerlink" title="方法三 使用filter"></a>方法三 使用filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// indexOf只会找元素的第一个位置，后面重复的不会被返回</span></span><br><span class="line">    <span class="keyword">return</span> index === array.indexOf(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>filter()</code>方法和<code>indexOf()</code>都是 ES5 的方法，IE9以下不兼容</p><h2 id="方法四-使用indexOf"><a href="#方法四-使用indexOf" class="headerlink" title="方法四 使用indexOf"></a>方法四 使用indexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arrlen = arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.indexOf(arr[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      ret.push(arr[i]); <span class="comment">// 将在 ret 数组中找不到的元素添加进去</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯粹的使用 <code>indexOf()</code> 实现，同样的有兼容性问题</p><h2 id="方法五-使用ES6的Set数据结构"><a href="#方法五-使用ES6的Set数据结构" class="headerlink" title="方法五 使用ES6的Set数据结构"></a>方法五 使用ES6的Set数据结构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const unique = arr =&gt; [...new Set(arr)];</span></span><br><span class="line"><span class="comment">// const unique = arr =&gt; Array.from(new Set(arr));</span></span><br></pre></td></tr></table></figure><p>Set 是 ES6 新增数据结构，特性是成员不能重复，利用这一特性，结合展开运算符或者<code>Array.from()</code>，可以用最简洁的代码实现数组去重，ES6 的代码需要经过编译后才能运行。</p><p>数组去重作为基本功，还是要掌握的，方法有多种，在合适的场景应选用合适的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>灵活的this</title>
    <link href="http://qyhever.top/2017/12/04/%E7%81%B5%E6%B4%BB%E7%9A%84this/"/>
    <id>http://qyhever.top/2017/12/04/灵活的this/</id>
    <published>2017-12-04T11:30:03.000Z</published>
    <updated>2018-06-20T13:30:25.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this作为js中的常用关键字，其指向一直是初学者头痛的地方，如果不理解它，在编写代码过程中会出现各种问题。</p><p>this对象是在运行时基于函数的执行环境绑定的，只能在函数内部使用，它和arguments一样，是函数调用时自动生成的。</p><p>函数调用有很多种方式，this的指向会不断变化。但是有一个一般的原则：this指向调用函数的那个对象。</p><p>一般来说，函数调用有四种方式，分别对应不同的this指向。下面来分析一下各种函数调用方式下的this指向。</p><h2 id="纯粹的函数调用（函数模式）"><a href="#纯粹的函数调用（函数模式）" class="headerlink" title="纯粹的函数调用（函数模式）"></a>纯粹的函数调用（函数模式）</h2><p>这是函数的通常用法，属于全局性调用，因此this就代表全局对象<code>window</code>。<code>window</code>只是浏览器环境中的全局对象，在严格模式下，this是<code>undefined</code>；在node环境中，this代表全局对象<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，匿名函数的执行环境具有全局性，因此其this对象通常指向<code>window</code>。</p></blockquote><h2 id="作为某个对象的方法调用（方法模式）"><a href="#作为某个对象的方法调用（方法模式）" class="headerlink" title="作为某个对象的方法调用（方法模式）"></a>作为某个对象的方法调用（方法模式）</h2><p>函数还可以作为某个对象的方法调用，也比较常用。当函数被作为某个对象的方法调用时，this就指向那个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  n: <span class="number">10</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面的foo函数做为obj对象的方法调用，this指向obj对象，因此结果是10。</p><p>方法调用有个特例：</p><p>如果函数作为某个数组的成员，调用这个函数，this的会指向window吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>); &#125;, <span class="number">1</span>, <span class="string">'a'</span> ];</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// [f, 1, 'a']</span></span><br></pre></td></tr></table></figure><p>js中的数组并不像传统语言中的常规数组，并不是起始地址+长度构成的一片连续的空间。js中的数组是对象，只不过会自动管理索引和length属性而已。</p><p>因为数组是对象，上面调用匿名函数是通过数组对象来调用，因此this指向数组对象arr。</p><h2 id="作为构造函数调用（构造器模式）"><a href="#作为构造函数调用（构造器模式）" class="headerlink" title="作为构造函数调用（构造器模式）"></a>作为构造函数调用（构造器模式）</h2><p>构造函数就是使用new关键字调用这个函数生成一个新对象，这时候的this代表new出来的新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure><p>在js中，函数也是对象。在调用构造函数时，会自动创建一个新对象，将构造函数的作用域赋给新对象（因此this就指向了新对象），再执行构造函数中的代码，最后隐式返回新对象。</p><blockquote><p>注意：任何函数，只要通过new操作符来调用，那它就可以作为构造函数；如果不通过new操作符调用，那么它跟普通函数没什么区别。另外，构造函数名一般首字母要大写，以便于和普通函数的区分。</p></blockquote><h2 id="通过apply、call调用（上下文模式）"><a href="#通过apply、call调用（上下文模式）" class="headerlink" title="通过apply、call调用（上下文模式）"></a>通过apply、call调用（上下文模式）</h2><p><code>apply()</code>是函数对象的一个方法，它的作用是改变函数的调用对象。第一个参数是调用这个函数的对象，如果为<code>null</code>或者没有，则this指向<code>window</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'this is window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'this is obj'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> util = &#123;</span><br><span class="line">  name: <span class="string">'this is util'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">util.foo(); <span class="comment">// this is util</span></span><br><span class="line">util.foo.apply(<span class="literal">null</span>); <span class="comment">// this is window</span></span><br><span class="line">util.foo.apply(obj); <span class="comment">// this is obj</span></span><br></pre></td></tr></table></figure><p>把上面的<code>apply</code>换成<code>call</code>，结果完全相同。它们的区别在于接收参数的方式不同，对于<code>call()</code>方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数，也就是，在使用<code>call()</code>方法时，传递给函数的参数必须逐个列举出来。而<code>apply()</code>则可以将其余参数作为一个数组传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">sum.call(<span class="literal">null</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line">sum.apply(<span class="literal">null</span>, [<span class="number">10</span>, <span class="number">10</span>]); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>其实，<code>apply()</code>和<code>call()</code>强大的地方是它们可以改变函数的上下文执行环境，能够扩充函数运行的作用域。扩充作用域的最大好处，就是对象与方法不需要有任何耦合关系，一个对象可以轻松借调另一个对象里的方法。</p><p><code>apply()</code>的常见应用：</p><ol><li>数组取最大值，数组并没有原生的取最大值的方法。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ol><li>数组合并</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>ES5定义了<code>bind()</code>方法，可以改变this指向，参数接收一个对象，将这个函数与这个对象绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'zs'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj);</span><br><span class="line">bar(); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p><code>apply()</code>，<code>call()</code>，<code>bind()</code>都可以改变this指向，但<code>bind()</code>只是绑定而不会立即调用；函数通过<code>apply()</code>和<code>call()</code>调用会立即执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于javascript的继承</title>
    <link href="http://qyhever.top/2017/11/29/%E5%85%B3%E4%BA%8Ejavascript%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://qyhever.top/2017/11/29/关于javascript的继承/</id>
    <published>2017-11-29T13:40:59.000Z</published>
    <updated>2018-06-20T13:30:25.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继承是oo语言中的一个常用的概念。在传统oo语言中为类与类之间的继承，而js则是对象与对象之间的继承。js中无法实现接口继承，只支持实现继承，基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>下面说一下常用的几种继承：</p><h2 id="原型链继承（类式继承）"><a href="#原型链继承（类式继承）" class="headerlink" title="原型链继承（类式继承）"></a>原型链继承（类式继承）</h2><p>通过子类型的原型prototype对父类型实例化来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.family = <span class="string">'zhang'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getParentFamily = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.family;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 子类型的原型prototype被赋值了父类型的实例</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">// 给子类型添加方法，需要放在替换原型语句之后，也不能使用字面量对象来添加方法</span></span><br><span class="line">Son.prototype.getSonAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(s.family); <span class="comment">// zhang</span></span><br><span class="line"><span class="built_in">console</span>.log(s.getParentFamily()); <span class="comment">// zhang</span></span><br></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>子类型的实例更改共有属性(子类型原型从父类型中继承来的属性)会影响到其他实例。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'bluc'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line">s1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"><span class="comment">// 对s1.colors的修改能够通过s2.colors反映出来，能充分证明</span></span><br></pre></td></tr></table></figure><p>引用类型值（Son）的原型属性会被所有实例（s1，s2）共享，一般我们都是在构造函数中定义属性，在原型上定义方法，属性是每个实例私有的，方法公用。在通过原型继承时，子类型的原型会变成会变成父类型的实例，原先在父类型中的实例属性现在变成了原型属性。</p><ul><li>在创建子类型的实例时，不能向父类型传递参数，无法对父类型中的属性进行初始化。</li></ul><blockquote><p>实际上，很少会单独使用原型链。</p></blockquote><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>有时候也叫<strong>伪造对象</strong>或<strong>经典继承</strong>。思想就是，在子类型型构造函数内部调用父类型型构造函数。函数只不过是在特定环境下执行的代码，因此可以通过apply()或call()在子类型中调用父类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的this就是将来的Son实例</span></span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以传参</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Son(<span class="string">'zs'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Son(<span class="string">'ls'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互不影响</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line">s1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.name); <span class="comment">// zs</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.name); <span class="comment">// ls</span></span><br></pre></td></tr></table></figure><p>关键性的一行<code>Parent.apply(this, arguments);</code>通过使用了<code>call()</code>或<code>apply()</code>方法，实际上是在(未来将要)新创建的<code>Son</code>实例的环境下调用了<code>Parent</code>构造函数。</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>可以传递参数，实例之间互不影响；但因为属性、方法都在构造函数中定义，所以函数复用就无从谈起了。在父类型原型上的方法，对子类型也是不可见的。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>有时候也叫<strong>伪经典继承</strong>，指的是将原型链和借用构造函数组合到一起。背后思想是使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有其自己的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name); <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 继承方法</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Son(<span class="string">'zs'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Son(<span class="string">'ls'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互不影响</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line">s1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.sayName()); <span class="comment">// zs</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.sayAge()); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.sayName()); <span class="comment">// ls</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.sayAge()); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>避免了原型链和借用构造函数的缺陷，融合了它们的优点，是js中最常用的继承模式。<code>instanseof</code>和<code>inPrototypeOf()</code>也能够用于识别基于组合创建的对象。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>并没有使用严格意义上的构造函数，主要思想是借助原型可以基于已有的对象创建新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回了基于o为原型的实例对象</span></span><br></pre></td></tr></table></figure><p>在<code>create</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时函数的一个新实例。其实，<code>create()</code>对传入的对象执行了一次浅复制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = create(o);</span><br><span class="line"><span class="keyword">var</span> s2 = create(o);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line">s1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors); <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br></pre></td></tr></table></figure><p>ES5中的<code>Object.create()</code>方法规范了这种原型式继承。它接受两个参数：一个用作新对象原型的对象和（可选）一个为新对象定义额外属性的对象。</p><p>如果只是想让一个对象与另一个对象保持类似，原型式继承完全可以胜任。但是，包含引用类型值的属性始终都会共享相应的值，例如上面的属性colors的修改。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承是与原型式继承机密相关的一种思路，背后思路是创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是做了所有工作一样返回对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = create(o); <span class="comment">// 实现继承</span></span><br><span class="line">  tmp.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 增加一些方法来增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person); <span class="comment">// 实现继承</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name); <span class="comment">// 继承了person的name属性</span></span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// 有自己的sayHi方法</span></span><br></pre></td></tr></table></figure><p>上面的代码基于<code>person</code>返回了一个新对象<code>anotherPerson</code>，新对象不仅具有<code>person</code>的所有属性和方法，还有自己的<code>sayHi()</code>方法。这里的<code>create</code>方法不是固定的，任何能够返回新对象的函数都使用于此模式。</p><h3 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h3><p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承是一种有效的方法；</p><p>使用寄生式继承来为对象来添加函数，会由于不能做到函数复用而降低效率。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承是js中最常用的模式，但是也有不足，最大的问题就是无论在什么情况下，都<strong>会调用两次父类型构造函数</strong>。一次是在创建子类型原型的时候，另一次是在子类型内部，子类型最终会包含父类型对象的全部实例属性，但是又不得不在调用子类型构造函数时重写这些属性。</p><p>再来看一看组合式继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一次调用<code>Parent</code>构造函数时，<code>Son.prototype</code>会得到两个属性，name和colors，它们都是父类型<code>Parent</code>的实例属性，而现在位于子类型<code>Son</code>的原型中。当调用子类型<code>Son</code>生成实例时，又会调用一次父类型<code>Parent</code>，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就覆盖了原型中的两个同名属性。结果就是，有两组name和colors属性，一组在实例上，一组在原型中。</p><p>寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成方法来继承方法。基本思路就是，不必为了指定子类型的原型而调用父类型，所需要的只不过是父类型的一个副本。即<strong>使用寄生式继承来继承父类型的原型，在将结果指定给子类型的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Son, Parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = create(Parent.prototype); <span class="comment">// 创建父类型的原型副本</span></span><br><span class="line">  tmp.constructor = Son;</span><br><span class="line">  Son.prototype = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>inheritPrototype()</code>函数实现继承组合式继承的最简单形式：</p><ol><li>创建父类型原型的一个副本</li><li>为创建的副本添加<code>constructor</code>属性，来弥补因重写而失去默认的<code>constructor</code>属性</li><li>将副本（父类型原型的）赋值给子类型的原型</li><li>可以调用<code>inheritPrototype()</code>函数来替换掉前面为子类型原型赋值的语句了</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Son, Parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = create(Parent.prototype); <span class="comment">// 创建父类型的原型副本</span></span><br><span class="line">  tmp.constructor = Son;</span><br><span class="line">  Son.prototype = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Son, Parent);</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>只调用了一次父类型<code>Parent</code>，避免了在<code>Son.prototype</code>上创建多余的属性，同时，原型链还能保持不变，还可以使用<code>instanceof</code>和<code>isPrototypeOf</code>，是最理想的继承方式。</p><h2 id="另外的方式"><a href="#另外的方式" class="headerlink" title="另外的方式"></a>另外的方式</h2><h3 id="mixin混入（拷贝）"><a href="#mixin混入（拷贝）" class="headerlink" title="mixin混入（拷贝）"></a>mixin混入（拷贝）</h3><p>让一个对象拥有另一个对象的属性和方法，可以用mixin直接将对象的属性和方法强制copy到另一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj2) &#123;</span><br><span class="line">    obj1[k] = obj2[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6中提供的更简单的<code>Object.assign()</code></p><p>这段代码就实现了最简单的从一个对象复制属性和方法到另一个对象。与原型链继承类似，两个对象是一个引用地址，会相互影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
      <category term="面向对象" scheme="http://qyhever.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>对象浅拷贝与深拷贝</title>
    <link href="http://qyhever.top/2017/11/15/%E5%AF%B9%E8%B1%A1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://qyhever.top/2017/11/15/对象浅拷贝与深拷贝/</id>
    <published>2017-11-15T12:42:51.000Z</published>
    <updated>2018-06-20T13:30:25.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在js中，当一个变量向另一个变量复制引用类型的值时，这两个变量实际上引用的是同一个对象，因此，改变其中一个变量，就会影响一个变量。（在栈里面有两个引用地址，都指向堆中的同一个对象）</p><p>使用<code>=</code>对数组和对象进行复制操作，完全是不可靠的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; name: 'jerry' &#125;</span></span><br></pre></td></tr></table></figure><p>如上，arr2的修改影响到了arr1，obj2的修改影响到了obj1，这显然不符合我们的预期，下面就来介绍一下数组以及对象的拷贝。</p><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><ul><li><p>for循环</p><p>通常情况下，可以直接使用for循环，将每个成员放到新变量中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [],</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    ret.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr1);</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>for循环比较容易理解，不过有点繁琐</p></li><li><p>使用slice</p><p><code>slice()</code>方法，它能够基于当前数组中的一个或多个项创建一个新数组（截取），只要截取全部，就完成了复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.slice();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr1);</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>很简洁，比较常用</p></li><li><p>使用concat</p><p><code>concat()</code>方法，可以将当前数组和另外的数组连接，返回一个新数组，不给它连接的数组，就会返回一个当前数组的副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.concat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr1);</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>和<code>slice()</code>一样简洁，也比较常用</p></li><li><p>使用apply</p><p>让新数组调用push()方法，把当前数组的成员放到新数组中，通过<code>apply()</code>调用，正好可以传递数组参数，实现复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push(arr2, arr1);</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>思路比较妙，不过代码语义不明显</p></li><li><p>使用map</p><p><code>map()</code>方法可以基于当前对象，返回一个当前对象的映射，我们对每个成员不做任何修改，返回的就是当前数组的副本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr1);</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>使用扩展运算符</p><p>es6新增的<code>...</code>运算符，可以将数组变成一个个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>使用<code>...</code>可以说是最简单的了</p><p>以上方法只适用于浅拷贝，适用于数组成员都是基本类型，如果是引用类型，就要使用深拷贝了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝不适用于成员为引用类型</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, &#123; name: 'jerry' &#125;];</span></span><br></pre></td></tr></table></figure><p>数组深拷贝可以归纳到对象深拷贝中，下面在对象深拷贝再讨论</p></li></ul><h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><h4 id="对象浅拷贝"><a href="#对象浅拷贝" class="headerlink" title="对象浅拷贝"></a>对象浅拷贝</h4><ul><li><p>对象的浅拷贝可以用for-in循环实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">source, dest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> source) &#123;</span><br><span class="line">    dest[k] = copyObj[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = copyObj(o1);</span><br><span class="line">o2.tom = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; name: 'tom' &#125;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>使用<code>Object.create()</code>方法</p><p><code>Object.create()</code>方法返回一个以当前对象为原型的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1);</span><br><span class="line">o2.name = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;name: 'tom'&#125;</span></span><br></pre></td></tr></table></figure><p>模拟<code>Object.create()</code>内部原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 临时声明一个构造函数，使这个构造函数的prototype指向父对象，然后生成一个实例并返回</span></span><br></pre></td></tr></table></figure></li><li><p>使用ES6的<code>Object.assign()</code></p><p><code>Object.assign()</code>用于对象的合并，合并若干个对象，返回一个新对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.assign(&#123;&#125;, o1);</span><br><span class="line">o2.name = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;name: 'tom'&#125;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h4 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h4><p>深拷贝，就是能够实现真正意义上的数组和对象的拷贝，只要递归调用浅拷贝就可以实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">undefined</span>) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = deepClone(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">        copy[k] = deepClone(obj[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This type is not supported.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了数组和对象两种常见的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">city</span>: [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>, <span class="string">'guangzou'</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = deepClone(o1);</span><br><span class="line">o2.city.push(<span class="string">'shengzhen'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;city: ['beijing', 'shanghai', 'guangzou']&#125;;</span></span><br></pre></td></tr></table></figure><p>还可以使用JSON序列化再反序列化实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">city</span>: [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>, <span class="string">'guangzou'</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o1));</span><br><span class="line">o2.city.push(<span class="string">'shengzhen'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;city: ['beijing', 'shanghai', 'guangzou']&#125;;</span></span><br></pre></td></tr></table></figure><p>这种方式有缺陷，在序列化js对象时，所有函数即原型成员都会被有意忽略，不体现在结果中。此外，值为<code>undefined</code>的任何属性也都会被跳过。</p><h5 id="jquery中的extend方法"><a href="#jquery中的extend方法" class="headerlink" title="jquery中的extend方法"></a>jquery中的extend方法</h5><p><code>$.extend()</code>很强大，可以实现对象的浅拷贝，深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = $.extend([], arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组深拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, &#123;<span class="attr">name</span>: <span class="string">'tom'</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = $.extend(<span class="literal">true</span>, [], arr); <span class="comment">// 第一个参数为true,则递归调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'tom'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = $.extend(&#123;&#125;, o1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象深拷贝</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">city</span>: [<span class="string">'beijing'</span>, <span class="string">'shanghai'</span>, <span class="string">'guangzou'</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = $.extend(<span class="literal">true</span>, &#123;&#125;, o1);</span><br></pre></td></tr></table></figure><p>第三方工具库lodash中也有深拷贝方法<code>_.cloneDeep()</code>，可以满足开发需要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的字符串方法</title>
    <link href="http://qyhever.top/2017/10/29/js%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <id>http://qyhever.top/2017/10/29/js中的字符串方法/</id>
    <published>2017-10-29T11:40:15.000Z</published>
    <updated>2018-06-20T13:30:25.623Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>js中的<code>String</code>类型用于表示有零或多个16位<code>Unicode</code>字符组成的字符序列，即字符串。可以有双引号或单引号表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>推荐使用单引号，可以少按<code>shift</code>，看上去也更简洁。</p><p><code>String</code>类型是字符串的对象包装类型，所以也可以使用<code>String</code>构造函数来创建（不建议使用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><ul><li><p><code>toString()</code>：大部分类型（<code>undefined</code>和<code>null</code>没有）都有<code>toString()</code>方法，返回相应值的字符串表现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log( num.toString() ); <span class="comment">// '1'</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log( flag.toString() ); <span class="comment">// 'true'</span></span><br></pre></td></tr></table></figure></li><li><p><code>String()</code>：使用转型函数可以将任何类型的值转换为字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">String</span>(a) ); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">String</span>(b) ); <span class="comment">// 'true'</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">String</span>(c) ); <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">String</span>(d) ); <span class="comment">// 'null'</span></span><br></pre></td></tr></table></figure></li><li><p>使用加号操作符把某个值与字符串拼接，也可以进行转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a + <span class="string">''</span> ); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log( b + <span class="string">''</span> ); <span class="comment">// 'true'</span></span><br><span class="line"><span class="built_in">console</span>.log( c + <span class="string">''</span> ); <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log( d + <span class="string">''</span> ); <span class="comment">// 'null'</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>js提供两个访问字符串中特定字符的方法：<code>chatAt()</code>和<code>charCodeAt()</code>。接收一个参数，从0开始的字符位置（相当于数组中的索引）。</p><ul><li><p><code>charAt()</code>返回给定位置的那个字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.charAt(<span class="number">2</span>) ); <span class="comment">// 'l'</span></span><br></pre></td></tr></table></figure></li><li><p><code>charCodeAt()</code>返回给定位置的字符编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.charCodeAt(<span class="number">1</span>) ); <span class="comment">// 101，小写字母“e”的字符编码</span></span><br></pre></td></tr></table></figure></li></ul><p>类似于数组，字符串也可以使用中括号语法来访问某个字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str[<span class="number">0</span>] ); <span class="comment">// 'h'</span></span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li><p><code>concat()</code>：用于将一个或多个字符串拼接起来，返回拼接过后的新字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tom = <span class="string">'tom'</span>;</span><br><span class="line"><span class="keyword">var</span> jerry = <span class="string">'jerry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( tom.concat(jerry) ); <span class="comment">// 'tomjerry'</span></span><br><span class="line"><span class="built_in">console</span>.log( tom.concat(jerry, <span class="string">'hello'</span>, <span class="string">'!'</span>) ); <span class="comment">// 'tomjerryhello!'</span></span><br></pre></td></tr></table></figure><p>虽然<code>concat()</code>是专门用来拼接字符串的，但实际上，拼接字符串更多的还是使用加号操作符（+）。</p></li></ul><p>js提供了三个基于字符串创建新字符串的方法（截取方法）：<code>slice()</code>、<code>substring()</code>、<code>substr()</code>。</p><p>都会返回被操作过后的新字符串。</p><ul><li><p><code>slice()</code>：从开始位置截取到结束位置，如果只有一个参数，则截取到最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 'tr'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.slice(<span class="number">1</span>) ); <span class="comment">// 'tring'</span></span><br></pre></td></tr></table></figure></li><li><p><code>substring()</code>：与<code>slice()</code>完全一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.substring(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 'tr'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substring(<span class="number">1</span>) ); <span class="comment">// 'tring'</span></span><br></pre></td></tr></table></figure></li><li><p><code>substr()</code>：接收两个参数：开始位置、长度。如果只有一个参数，则截取到最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.substr(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 'tri'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substr(<span class="number">1</span>) ); <span class="comment">// 'tring'</span></span><br></pre></td></tr></table></figure></li></ul><p>如果传入的参数为负值，3个方法的处理各不相同。</p><ul><li><code>slice()</code>将传入的负值与字符串的长度相加</li><li><code>substring()</code>将所有负值参数都转换为0</li><li><code>substr()</code>将负的第一个参数与字符串的长度相加，将负的第二个参数转换为0</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.slice(<span class="number">-2</span>) ); <span class="comment">// 'ld'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substring(<span class="number">-2</span>) ); <span class="comment">// 'hello world'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substr(<span class="number">-2</span>) ); <span class="comment">// 'ld'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( str.slice(<span class="number">2</span>, <span class="number">-4</span>) ); <span class="comment">// 'llo w'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substring(<span class="number">2</span>, <span class="number">-4</span>) ); <span class="comment">// 'he'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.substr(<span class="number">2</span>, <span class="number">-4</span>) ); <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><blockquote><p>这4个操作都返回一个基本类型的字符串值，对原始字符串没有任何影响。</p></blockquote><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>从字符串中查找字符串的方法：<code>indexOf()</code>和<code>lastIndexOf)</code>。从字符串中查找给定的一个字符，返回字符的位置（如果没有找则返回-1）。<code>indexOf()</code>从前向后查找，<code>lastIndexOf()</code>从后向前查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.indexOf(<span class="string">'o'</span>) ); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log( str.lastIndexOf(<span class="string">'o'</span>) ); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>第二个参数指定从哪个位置开始查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.indexOf(<span class="string">'o'</span>, <span class="number">5</span>) ); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log( str.lastIndexOf(<span class="string">'o'</span>, <span class="number">5</span>) ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><p>字符串有一个<code>trim()</code>方法，可以去除空格。这个方法会创建一个字符串的副本，删除前面即后面的所有空格，然后放回这个副本。这在表单验证中是非常有用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">' abc  '</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.trim() ); <span class="comment">// 'abc'</span></span><br></pre></td></tr></table></figure><h3 id="大小写转换方法"><a href="#大小写转换方法" class="headerlink" title="大小写转换方法"></a>大小写转换方法</h3><p>字符串大小写转换的方法有4个：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>、<code>toLocaleUpperCase()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.toUpperCase() ); <span class="comment">// 'ABC'</span></span><br><span class="line"><span class="built_in">console</span>.log( str.toLocaleUpperCase() ); <span class="comment">// 'ABC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">'TOP'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( value.toLowerCase() ); <span class="comment">// 'top'</span></span><br><span class="line"><span class="built_in">console</span>.log( value.toLocaleLowerCase() ); <span class="comment">// 'top'</span></span><br></pre></td></tr></table></figure><p><code>toLocaleLowerCase()</code>、<code>toLocaleUpperCase()</code>的结果与<code>toLowerCase()</code>、<code>toUpperCase()</code>的结果完全一样，但在不同的地区、不同语言环境可能会有不同的结果。因此，使用前面的两个方法更靠谱一点。</p><h3 id="模式匹配方法"><a href="#模式匹配方法" class="headerlink" title="模式匹配方法"></a>模式匹配方法</h3><p><code>String</code>类型定义了几个用于在字符串中匹配模式的方法：<code>match()</code>、<code>search()</code>、<code>replace()</code>、<code>split()</code></p><ul><li><p><code>match()</code>：接收一个参数，参数为正则表达式。返回一个数组，数组保存着与正则匹配的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'ert, bat, cat, dat'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> matches = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(matches); <span class="comment">// ["bat", "cat", "dat"]</span></span><br></pre></td></tr></table></figure><blockquote><p>如果调用<code>RegExp</code>对象的<code>exec()</code>方法传递上面的字符串为参数，会得到与上面相同的结果。</p></blockquote></li><li><p><code>search()</code>：接收一个参数，参数为正则表达式。返回字符串中第一个匹配项的位置，如果匹配不到，返回-1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cct, bat, sat, fat'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/at/</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(reg); <span class="comment">// 返回‘at’在字符串中第一次出现的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p><code>replace()</code>：接收两个参数：正则表达式（或字符串）、字符串（或函数）。第一个参数如果为字符串，只会替换第一个子字符串。替换所有子字符串，可以传入正则表达式，并指定全局<code>g</code>标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cct, bat, sat, fat'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( text.replace(<span class="string">'at'</span>, <span class="string">'go'</span>) ); <span class="comment">// 'cct, bgo, sat, fat'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( text.replace(<span class="regexp">/at/g</span>, <span class="string">'go'</span>) ); <span class="comment">// 'cct, bgo, sgo, fgo'</span></span><br></pre></td></tr></table></figure><p>第二个参数为函数，函数传递3个参数：模式的匹配项、匹配项在字符串中的位置、原始字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'&lt;p class=\"info\"&gt;hello!&lt;/p&gt;'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="keyword">return</span> <span class="string">'&amp;lt;'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>: <span class="keyword">return</span> <span class="string">'&amp;gt;'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&amp;'</span>: <span class="keyword">return</span> <span class="string">'&amp;amp;'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\"'</span>: <span class="keyword">return</span> <span class="string">'&amp;quot;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的回调函数对小于号、大于号、和号、双引号进行了转义。</p></li><li><p><code>split()</code>：基于指定的分隔符将字符串分割成多个子字符串，将结果放在一个新数组中并返回。接收两个参数：分隔符（字符串或正则表达式）、指定生成数组的大小</p></li></ul><ul><li><p>不传递参数，会把整个字符串作为数组的第一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'s,c,r,i,p,t'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.split() ); <span class="comment">// ["s,c,r,i,p,t"]</span></span><br></pre></td></tr></table></figure></li><li><p>传递一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'s,c,r,i,p,t'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.split(<span class="string">','</span>) ); <span class="comment">// ["s", "c", "r", "i", "p", "t"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递正则，取得包含逗号字符的数组</span></span><br><span class="line"><span class="built_in">console</span>.log( str.split(<span class="regexp">/[^\,]+/</span>) ); <span class="comment">// ["", ",", ",", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure></li><li><p>传递两个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'s,c,r,i,p,t'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.split(<span class="string">','</span>, <span class="number">4</span>) ); <span class="comment">// ["s", "c", "r", "i"]</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><p><code>localeCompare()</code>用来比较两个字符串：接收一个字符串参数</p><ul><li>相等返回0</li><li>字符串在字母表中排在参数字符串之前，返回负数（-1）</li><li>字符串在字母表中排在参数字符串之后，返回负数（1）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'pink'</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.localeCompare(<span class="string">'pink'</span>) ); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log( str.localeCompare(<span class="string">'red'</span>) ); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log( str.localeCompare(<span class="string">'black'</span>) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="formCharCode-方法"><a href="#formCharCode-方法" class="headerlink" title="formCharCode()方法"></a>formCharCode()方法</h3><p>这是<code>String</code>构造函数的一个静态方法，接收一个或多个字符编码，将它们转换成字符串。这个方法与实例方法<code>charCodeAt()</code>执行的是相反的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">String</span>.formCharCode(<span class="number">104</span>, <span class="number">105</span>) ); <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><h3 id="拼接字符串性能"><a href="#拼接字符串性能" class="headerlink" title="拼接字符串性能"></a>拼接字符串性能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">a += <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure><p>上面的变量<code>a</code>开始时包含字符串<code>hello</code>，而第二行代码把<code>a</code>的值重新定义为<code>hello</code>与<code>world</code>的组合，即<code>helloworld</code>。实现这个操作的过程为：首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充<code>hello</code>和<code>world</code>，最后还要销毁原来的字符串<code>hello</code>和<code>world</code>。这个过程是在后台发生的，会导致在某些低版本浏览器中拼接字符串速度很慢。</p><p>开发中会遇到大量拼接字符串的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'concat'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  tag += <span class="string">'&lt;div&gt;i&lt;/div&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'concat'</span>);</span><br></pre></td></tr></table></figure><p>对于上面的情况可以使用数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tag = <span class="string">''</span>, arr = [];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'concat'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  arr.push(<span class="string">'&lt;div&gt;i&lt;/div&gt;'</span>);</span><br><span class="line">&#125;</span><br><span class="line">tag = arr.join(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'concat'</span>);</span><br></pre></td></tr></table></figure><p>在浏览器测试可以看到，改进的写法消耗时间明显少于原来的写法。因此，大量拼接字符串推荐使用数组进行转换。</p><p>字符串操作与数组操作同样重要，熟悉字符串的一些方法是很有必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="js" scheme="http://qyhever.top/categories/js/"/>
    
    
      <category term="js" scheme="http://qyhever.top/tags/js/"/>
    
  </entry>
  
</feed>
